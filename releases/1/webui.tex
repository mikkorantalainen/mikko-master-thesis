\documentclass[finnish,latin1,nocopyright,nonumbib]{gradu2}
% options for gradu2: (no)copyright, (no)numbib, newtitle, shortthesis, altsubsec

\title{Aidosti selainkäyttöisten sovellusten suunnittelu ja toteutus}
\translatedtitle{Design and Implementation of Truly Web Based User Interfaces}

\tiivistelma{Tämä pro gradu sisältää kuvauksen siitä, kuinka www-selaimella toimivat käyttöliittymät eroavat perinteisistä käyttöliittymissä natiivisti toimivista ohjelmista ja kuinka tämä tulisi ottaa huomioon käyttöliittymän suunnittelussa ja toteutuksessa. Vastapainona teorialle kuvailen Peda.net -projektissa ja -hankkeessa tekemiäni selainkäyttöisiä sovelluksia ja niissä tehtyjä kompromisseja.}
\avainsanat{käyttöliittymä, selain, www, verkko, sovellus, HTML, CSS, XHTML, XML}

\abstract{This master's thesis contains a short description about how web based user interfaces differ from traditional native user interfaces and how this relates to the design and implementation of web based user interface. In addition to theory, I will describe some web browser accessible applications that I have developed in Peda.net project. I will discuss technical decisions, compromises and advancements in the more recent applications.}
\keywords{user interface, browser, www, web, application, HTML, CSS, XHTML, XML}


%\author{Mikko Rantalainen}{mira@cc.jyu.fi}
\setauthor{Mikko}{Rantalainen}
\setdate{01}{06}{2004}
\tyyppi{Pro Gradu -ehdotus}
\type{A Master's Thesis Candidate}

\yhteystiedot{Mikko Rantalainen \texttt{<mikko.rantalainen@iki.fi>}}
\license{ffff}
%\copyrightowner{Mikko Rantalainen}
%\copyrightyear{2004}

% käytetään pakettia amssymb mathbb{} funktion hakuun
%\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}

\newcommand{\strong}[1]{\textbf{#1}}
\newcommand{\class}[1]{\texttt{#1}}
\newcommand{\method}[1]{\texttt{#1}}
\newcommand{\command}[1]{\texttt{#1}}
\newcommand{\keyword}[1]{\texttt{#1}}
\newcommand{\element}[1]{\texttt{#1}}
\newcommand{\attribute}[1]{\texttt{#1}}
\newcommand{\tag}[1]{\texttt{#1}}
\newcommand{\alt}[1]{\textsl{#1}}
\newcommand{\term}[1]{\textsl{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\newenvironment{terms}
  {\begin{description}\renewcommand{\makelabel}[1]{#1\hfill}}
  {\end{description}}


\begin{document}

\hyphenation{mo-zilla net-scape in-ter-net ex-plor-er XHTML HTML SMIL SVG}

% all these settings require Listings package version 1.0. Usually only version 0.20 is available.
%\lstset{extendedchars=true,basicstyle=\ttfamily,firstnumber=1,breaklines=true,xleftmargin=6mm}
\lstset{extendedchars=true,basicstyle=\ttfamily}


\preface

Voidaan perustellusti väittää, että jokainen www-sivuja tehokkaasti lukeva ja verkossa olevaa materiaalia hyväkseenkäyttävä henkilö on tietoinen www-selainten perusominaisuuksista. Tärkein, erityisesti www-selaimelle tyypillinen toiminto, on ns. \emph{takaisin}-toiminto (\alt{back}), jolla voidaan sivuhistoriassa palata edelliselle sivulle. Jos käyttäjä huomaa sisällysluettolosta jonkin kohdan valittuaan, että valinta oli väärä, voi hän tämän toiminnon avulla välittömästi palata takaisin sisällysluetteloon miettimättä olisi valinnan seurauksena annetulla sivulla ollut jokin keino siirtyä sisällysluetteloon. Linkkien seuraamisen jälkeen www-sivuja käyttävä henkilö oppii \emph{takaisin}-toiminnon käytön. Jos verkossa linkkien seuraamistaito vastaa lukemaan oppimista, niin takaisin-toiminnon käyttö vastaa kirjoittamista. Tästä huolimatta selainkäyttöisessä sovelluksessa \emph{takaisin}-toiminnon käyttäminen aiheuttaa ohjelman rikkoutumisen. Selainkäyttöisten ohjelmien kehittäjien yleinen kysymys onkin, kuinka \emph{takaisin}-toiminnon käyttö voitaisiin estää, kun oikea kysymys olisi miksi se pitäisi estää? Jos käyttäjä selvästi haluaa suorittaa kyseisen toiminnon, niin eikö jotain pitäisi tehdä sen hyväksi, että käyttäjä voisi tuon toiminnon tehdä? Muita usein tavallisten sivujen yhteydessä käytettyjä toimintoja, jotka eivät toimi monessa selainkäyttöisessä sovelluksessa, ovat mm. linkin avaaminen toisessa ikkunassa ja kirjanmerkin luominen.

Syitä siihen, että takaisin-toiminnon käyttö rikkoo monia selainkäyttöisiä sovelluksia, täytyy etsiä perinteisen ohjelmistokehityksen malleista. Viimeistään graafisten käyttöliittymien myötä on tullut yleiseksi tapahtumankäsittelijään perustuva käyttöliittymän ohjelmointimalli. Siinä ohjelman tilaa ohjaillaan erilaisilla tapahtumilla ja ohjelma toimii aina sen hetkisen tilan mukaan. WWW-sivujen taustalla toimiva HTTP-protokolla ei kuitenkaan pidä yhteyttä palvelimeen koko ajan, vaan yhteys katkeaa välittömästi yksittäisen sivun saamisen jälkeen ja erityisesti selain ei lähetä palvelimelle mitään tietoa takaisin-toiminnon suorittamisesta. Esimerkiksi, jos palvelimella ajetaan yksinkertaiseen tapahtumankäsittelijään perustuvaa sovellusta, saa se ensin tiedon siitä, että käyttäjä haluaa siirtyä johonkin tilaan (esimerkiksi valinta siirtyä sisällysluettelosta lukuun 1.3), mutta sovellukselle ei tule tietoa siitä, että käyttäjä tämän jälkeen palasi takaisin sisällysluetteloon käyttämällä takaisin-toimintoa. Jos käyttäjä tämän jälkeen valitsee sovelluksessa "Muokkaa"-toiminnon, tulee muokkaus sovelluksen tilan perusteella osoittaa lukuun 1.3, mutta käyttäjän mielestä sisällysluetteloon.

\termlist

\begin{terms}
\item[HTML] HyperText Markup Language (\alt{HTML}) on tekstimuotoinen esitystapa rakenteisen dokumentin esittämiseen.
\item[XHTML] Extensible HyperText Markup Language (\alt{XHTML}) on HTML-kielen XML-kielinen versio, jolla kirjoitetuissa dokumenteissa voidaan käyttää myös muita XML-kielen sovelluksia, kuten esimerkiksi MathML-kieltä matemaattisten merkintöjen tekemiseen.
\end{terms}


% start the content (end of header)
\mainmatter

\chapter{Selainkäyttöliittymän ongelmia}

Ohjelmistotuotannossa käyttäjän kanssa vuorovaikutuksessa toimiva ohjelmisto pyritään perinteisesti jakamaan kahteen tai kolmeen kerrokseen. Kaksikerroksisessa mallissa (kuva \ref{fig:2tier}) ohjelman logiikka erotetaan käyttöliittymälogiikasta ja kolmikerroksisessa mallissa (kuva \ref{fig:3tier}) ohjelman logiikka jaetaan vielä sovelluslogiikkaan ja tiedon käsittelyn logiikkaan. Molemmissa malleissa käyttöliittymä pidetään omassa kerroksessaan erityisesti siksi, että vaihtoehtoisen käyttöliittymän rakentaminen olisi mahdollisimman helppoa. Käytännössä käyttöliittymästä vastaava kerros kutsuu melkein kaikkien toimintojen yhteydessä käyttöliittymälogiikkaa ja itse käyttöliittymäkerroksessa on kohtuullisen vähän ohjelmakoodia. Tämän ansiosta ohjelma on yleensä helppo siirtää esimerkiksi toimimaan jonkin toisen grafiikkakirjaston päälle. Kolmikerrosmallissa etuna on helppo siirrettävyys uudelle tallennusmedialle.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=5cm]{kuvat/fig2tier}
\caption{Kaavio kaksikerroksista ohjelma-arkkitehtuurista}
\label{fig:2tier}
\end{center}
\end{figure}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=5cm]{kuvat/fig3tier}
\caption{Kaavio kolmikerroksista ohjelma-arkkitehtuurista}
\label{fig:3tier}
\end{center}
\end{figure}

Verkossa toimivissa eli useinmiten selainkäyttöisissä ohjelmissa eteen tulee perinteisessä mallissa kohtaamattomia ongelmia: käyttöliittymän toiminta on yhteydetön, käyttäjä voi haarauttaa istunnon ja järjestelmä ei voi erottaa verkon virheellistä toimintaa ja käyttäjän hieman tavallisesta poikkeavaa käyttäytymistä toisistaan. Lisäksi eri selainohjelmien toteutuksissa on usein merkittäviä ohjelmavirheitä.

Teknisten ongelmien lisäksi tulee ottaa huomioon myös käyttäjien tottumukset ja selainohjelmien pääasiallinen käyttötarkoitus: www-sivujen selailu. Eri selainohjelmissa on erilaisia erikoistoimintoja tavallisten sivujen selailun nopeuttamiseksi ja tehostamiseksi. Selaimella käytettävien ohjelmien tulisi toimia mahdollisuuksien rajoissa aivan kuin tavallisten www-sivujenkin.

Käsittelen ensin selaimella käytettävien sovellusten toteutukseen liittyviä ongelmia ja kuvaan lopuksi yhden ratkaisumallin verkkosovellusten tekoon. En käsittele yleisesti verkon yli toimivia ohjelmia, joiden käyttöliittymän logiikka kuitenkin suoritetaan natiivisti asiakkaan päässä. Näihin lukeutuvat myös kaikki Java-pohjaiset asiakasohjelmat.

Verkossa toimivissa selainpohjaissa käyttöliittymissä perustavanlaatuinen ongelma on, että HTML on suunniteltu pääasiassa staattisten dokumenttin esittämiseen \cite{w3:html}. Käyttäjäagentit eli selaimet on suunniteltu pääasiassa staattisten sivukokonaisuuksien lukemiseen ja sen vuoksi selaimissa on esimerkiksi \emph{takaisin}-toiminto (\alt{Back}). Lisäksi selaimet käyttävät sivujen tiedonsiirrossa HTTP-protokollaa, jonka seurauksena käyttöliittymät eivät ole koko ajan yhteydessä palvelimen päässä toimivaan sovelluslogiikkaan. Perinteiset käyttöliittymien suunnittelutavat ja toteutusmallit soveltuvat huonosti selainkäyttöiseen käyttöliittymän toteukseen. Esittelen seuraavassa muutamia suurimpia ongelmia, jotka syntyvät pohjalla olevista arkkitehtuurieroista.

\section{Yhteydetön käyttöliittymä}

WWW-selaimet käyttävät tiedon siirtoon HTTP-yhteyttä tai SSL-salattua HTTP-yhteyttä (\alt{HTTPS}). Molemmat näistä yhteysmalleista ovat loogisesti yhteydettömiä, vaikka tehokkuuden vuoksi todelliset toteutukset pitäväkin yhteyden usein auki eri dokumenttien noutamisen välillä. Selain voi milloin tahansa katkaista entisen yhteyden ja luoda uuden, mutta tämä ei saa vaikuttaa ohjelman toimintaan.

Yhteydettömän toiminnan vuoksi käyttöliittymän toiminnot täytyy suunnitella siten, että yhdellä lomakkeella tehtävät toiminnot eivät vaadi ohjelman sisältöön puuttumista ennen seuraavalle lomakkeelle siirtymistä. Ongelma voidaan osittain kiertää käyttämällä JavaScript-skriptikieltä asiakkaan selainohjelmassa, mutta koska verkkoympäristössä asiakasohjelmaan ei voi luottaa\footnote{JavaScript-skriptikielellä voi esimerkiksi tarkistaa onko syötekenttään käyttäjän kirjoittama tieto laskun viitenumero laskemalla onko viitenumeron viimeinen tarkistusnumero oikein. Jos tarkistusnumero ei toimi, näytetään varoitusikkuna ja pyydetään käyttäjää syöttämään tieto uudelleen. Kuitenkin, turvallisuussyistä sama tarkistus täytyy tehdä myös palvelimella (koska muuten pahantahtoinen asiakas voisi muuttaa selaimessa toimivaa JavaScript-ohjelmaa ja lähettää virheellisen numeron järjestelmään).}, täytyy sama sovelluslogiikka olla myös palvelimen päässä. Tästä seuraa, että sama toiminnallisuus täytyy esittää kahdella eri ohjelmointikielellä (JavaScript ja kieli, jolla palvelimen logiikka on tehty). Seurauksena on koko järjestelmän huomattavasti vaikeampi ylläpito, koska eri kielillä tehtyjen toimintojen täytyy vastata toisiaan. 

\section{Ongelmallinen takaisin-painike}

Kuten edellä mainitsin, selaimet on suunniteltu pääasiassa staattisten dokumenttien käyttämiseen. Lisäksi HTTP-protokollan määritys erikseen huomauttaa, että asiakasohjelman historiatietojen käytön ei tarvitse hakea tietoja palvelimelta \cite[kappale 13.13]{ietf:http}. Esimerkkitapaus ongelmatilanteesta on esitetty kuvassa \ref{fig:fork}. Esimerkissä käyttäjä siirtyy ensin sovelluslogiikan luomalle sivulle (lomakkeelle) $A$, valitsee toiminnon $a_1$ ja siirtyy sen seurauksena sivulle $B$. Tämän jälkeen käyttäjä voi käyttää selaimen \emph{takaisin}-toimintoa ja palata takaisin sivulle $A$. Koska tämä on siirtyminen selainohjelman historiatiedoissa, ei asiasta protokollan mukaisesti tarvitse ilmoittaa palvelimelle, joten sovelluslogiikan näkökulmasta asiakas on edelleen sivulla $B$. Tämän jälkeen asiakas valitsee edellisestä poikkevan toiminnon $a_2$. Palvelinohjelman tulee tässä vaiheessa kyetä huomaamaan, että vaikka sen tarjoama lomake olikin $B$, on käyttäjän valitsema toiminto $a_2$ ja toimintoon liittyvä tieto on peräisin lomakkeelta $A$, eikä lomakkeelta $B$.

Usein tähän ongelmaan käytetty ``ratkaisu'' on kertoa käyttäjälle, että sovelluksessa \emph{ei saa} käyttää \emph{takaisin}-toimintoa.\footnote{Tämä rajoitus seuraa yleensä siitä, sovellus yrittää pitää istunnon tilaa yllä. Usein tähän käytetään keksejä (\alt{cookies}). Näiden suurin ongelma on, että niihinkään ei voida helposti vaikuttaa historiatoimintojen yhteydessä ja lisäksi ne ovat globaaleja kaikkien selainohjelman näkymien (ikkunoiden) kesken. Jos istuntoa kuvaavassa keksissä säilytetään myös käyttäjän tunnistetietoja ei sovellukseen voi kirjautua monella eri käyttäjällä samanaikaisesti - paitsi jos käyttää eri selainohjelmaa jokaista käyttäjää kohden!} Olennaista on kuitenkin huomata, että käyttäjä teki tietoisen päätöksen käyttäessään -- tai yrittäessään käyttää -- kyseistä toimintoa ja varmastikin hän olisi halunnut sen tekevän jotain muuta, kuin näyttävän virheilmoituksen. Ohjelma tulee siis tehdä sellaiseksi, että se pystyy vastaanottamaan ja käsittelemään \emph{mahdollisimman suuren} osan käyttäjän lähettämästä tiedosta, vaikka muuttuneen tilanteen vuoksi osa siitä ei olisikaan relevanttia.

\section{Istunnon haarautuminen}

Istunnon haarautuminen liittyy hyvin läheisesti \emph{takaisin}-toimintoon. Siinä erona, käyttäjä kahdentaa aktiivisen lomakkeen $A$ ja valitsee ensimmäisessä ikkunassa toiminnon $a_3$ ja toisessa ikkunassa toiminnon $a_4$. Järjestelmä palauttaa toiminnon $a_3$ seurauksena sivun $C$ ja toiminnon $a_4$ seurauksena sivun $D$. Järjestelmän kannalta tämä tapahtuma näyttää täsmälleen samalta kuin \emph{takaisin}-toiminnon käyttökin, mutta merkittävä ero syntyy siitä, että seuraavaksi käyttäjä voi tuottaa rinnakkaisia tapahtumia sekä lomakkeelle $C$, että lomakkeelle $D$. Ei siis riitä, että palvelinohjelma pitää kirjaa käyttäjän toimintahistoriasta ja osaa peruuttaa lähetettyjen kutsujen mukaan oikeaan tilanteeseen; lisäksi ohjelman pitää kyetä haarauttamaan istuntoja epäsuorien tapahtumien kautta. Täysin oikean istuntoa kuvaavan tiedon ylläpitäminen palvelimella onkin vähintäänkin hyvin työlästä ellei mahdotonta. Istunnon tiedot täytyy siis jotenkin saada siirtymään selainohjelmassa ikkunakohtaisesti, jolloin ikkunan kahdentaminen kahdentaa myös istunnon.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=14cm]{kuvat/fork}
\caption{Kaavio istunnon haarautumisesta}
\label{fig:fork}
\end{center}
\end{figure}

\section{Verkon virheiden havaitseminen mahdotonta}

Yhteydettömästä käyttäliittymästä seuraa myös, että palvelin ei voi tunnistaa verkon virheellistä toimintaa asiakkaan selaimen sulkemisesta tai asiakkaan tietokoneen jumiutumisesta. Yllämainitut ongelmatilanteet  näkyvät palveliohjelmalle vastaavasti kuin asiakas vain käyttäisi epätavallisen kauan aikaa lomakkeen täyttämiseen. Tämän vuoksi mikään toiminto ei saisi lukittaa resursseja siihen asti kunnes ``käyttäjän istunto loppuu.'' Käytännössä tälläisia resurssien lukittamisia kuitenkin tarvitaan ja usein ratkaisuna on käyttää maksimiaikaa lukitukselle; kun käyttäjä valitsee esimerkiksi uutisartikkelin muokkauksen, merkitään muokattava artikkeli lukituksi, jolloin muut eivät voi sitä muokata. Lukitus puretaan kun käyttäjä tallentaa muokatun artikkelin tai kun ennaltamäärätty maksimiaika lukitukselle on kulunut.

\section{Selainten virheelliset toteutukset}

Kun palvelimen ohjelmisto on saatu toimimaan ja kaikki edellämainitut ongelmat on otettu huomioon, havaitaan, että eri selainohjelmat eivät toimi eri standardeissa määrätyllä tavalla. Useimmat vioista vaikuttavat ainoastaan käyttäjälle näkyvän lomakkeen ulkoasuun -- esimerkiksi joku teksti on suhteessa muuhun käyttöliittymään suuremmalla tekstillä kuin pitäisi. Kuitenkin osa vioista voi estää tiettyjen toimintojen käytön: esimerkiksi HTML-määrityksen mukaan yhden \code{file}-tyyppisen lomake-elemntin tulee tarjota mahdollisuus usean tiedoston siirtämiseen yhtä aikaa. Ainoa yleisesti käytössä oleva selain, joka toimii tässä mielessä määrityksen mukaisesti, on \emph{Opera}. Tämä näkyy myös yleisimmissä palvelinpään toteutuksissa siten, että Operalla monta tiedostoa yhtä aikaa lähetettäessä, tapahtuus palvelinpäässä yleensä virhe tiedostoja vastaanotettaessa, koska palvelinohjelmiston kehittäjä ei ole lukenut määritystä vaan ainoastaan tarkkaillut kuinka yleisimmät selaimet toimivat.
\cite{korpela:file_input}

Toinen yleinen virhe selainten toteutuksessa on tiedon lähettäminen UTF-8 koodauksella ilman siitä ilmoittamista -- protokollan mukaan oletuksena tulee tällöin käyttää ISO-8859-1-merkistöä jonka seurauksena kaikki ASCII-merkistön ulkopuoliset merkit siirretään väärin. Tässä siis puutteellisen toiminnan lisäksi tuhoutuu myös tietoa. Tämä ongelma voidaan kiertää lähettämällä lomakkella näkymätön kenttä, jonka sisältö on tunnettu ja sisältää ASCII-merkistön ulkopuolisia merkkejä, ja tarkastelemalla kuinka selain koodaa tämän kentän sisällön.




\chapter{Eräs ratkaisumalli selainkäyttöliittymän toteutukseen}

\emph{[ Tämä kappale on vuosi sitten kirjoittamaani tekstiä. Osa tekstistä ei vastaa tämänhetkistä sovellusta, koska PHP-ohjelmointikieli osoittautui tehottomaksi ja toteutus tarpeettoman työlääksi näin täytellisellä jakamisella eri kerroksiin. ]}

Suunnittelemani ratkaisumalli mm. ylläolevien ongelmien ratkaisemiseksi on kehittää sovelluskehys selainkäyttöliittymien ohjelmoimisen helpottamiseksi. Poiketen perinteisestä mallista, rakenteesta tulee näillä näkymin nelikerroksinen; erona kolmikerroksiseen malliin käyttöliittymälogiikka jakautuu kahteen osaan: käyttöliittymän toiminnallisuuden kuvaamiseen ja käyttöliittymäajuriin (kuva \ref{fig:4tier}).

\begin{figure}[htb]
\begin{center}
\includegraphics[width=10cm]{kuvat/fig4tier}
\caption{Kaavio nelikerroksista arkkitehtuurista usean sovelluksen tapauksessa}
\label{fig:4tier}
\end{center}
\end{figure}

Jaon etuna eri sovellusten käyttöliittymät saadaan toimimaan vastaavalla ulkonäöllä ja mahdollisimman pitkälti vastaavilla toiminnoilla. Tämä onnistuu jakamalla käyttöliittymäajuri eri sovellusten kesken. Uskon, että suunnittelemalla käyttöliittymän toiminnallisuuden ja käyttöliittymäajurin rajapinta sopivasti, helpottuu käyttöliittymän kirjoittaminen verrattuna entiseen malliin, jossa käyttöliittymää kirjoitettaessa jouduttiin kirjoittamaan koodi myös käyttöliittymän eri osien, kuten erilaisten painikkeiden, hallintaan.

Käyttöliittymäajuri keskustelee www-selaimen kanssa, mutta vaihtoehtoisesti sen voisi toteuttaa natiivilla sovelluksella. Koska toiminnallisuuden täytyy kuitenkin olla lomakepohjainen toimiakseen hyvin selaimen kautta, ei tälläinen natiivikäyttöliittymä olisi merkittävästi parempi kuin selainpohjainen käyttöliittymäkään.

\section{Tiedon käsittelyn logiikka}

Tämä kerros toteutetaan käyttämällä jotain olemassaolevaa tietokantaa, kuten MySQL tai PostgreSQL.

\section{Sovelluslogiikka}

Sovelluslogiikka vastaa sovelluksen ``älystä''. Käytännössä tämä kerros on todennäköisesti tehokkainta sulauttaa osittain käyttöliittymän toiminnallisuuden kanssa. Näin sen vuoksi, että sovelluslogiikkaan ei yleensä ohjelmoida ominaisuuksia, joita käyttöliittymän toiminnallisuus ei tarvitse ja toisaalta sulauttamisen haittojen voi olettaa olevan kohtuullisen pieniä käyttöliittymän toiminnallisuuden abstraktiuden vuoksi. Oletan, että erillisyydestä saatavat edut ovat pienemmät kuin siitä aiheutuvat haitat toteutusvaiheessa -- tätä pitäisi kuitenkin tutkia tarkemmin.

\section{Käyttöliittymän toiminnallisuus}

Käyttöliittymän toiminnallisuudesta vastaava kerros kuvaisi käyttöliittymän toiminnan abstraktilla tavalla: ``tästä taulukosta täytyy valita 2-5 riviä'' tai ``käyttäjän tulee syöttää lomakkeelle kaksi merkkijonoa. Näiden merkkijonojen nimet ja tyypit ovat 'käyttäjätunnus':merkkijono ja 'salasana':salattu merkkijono.'' Tämä kerros ei ota kantaa siihen missä järjestyksessä taulukon sarakkeet ja rivit näytetään tai siihen, syötetäänkö käyttäjätunnus tekstikenttään vai napauttelemalla hiirellä jonkin kuvan eri kohtia.

Teoriassa tämä kerros voisi generoida yksinkertaisen XML-sivun, joka muunnettaisiin XHTML tai HTML -sivuksi selaimen toimintoja varten. Tällöin käyttöliittymäajuri pitäisi käytännössä kirjoittaa XSLT-kielellä. Käytännössä tälläisen ajurin kirjoittaminen muodostuu olettavasti niin hankalaksi, että paremmalta vaihtoehdolta tuntuu kirjoittaa käyttöliittymäajuri kirjastoksi, joka linkitetään ohjelmaan sitä tehtäessä. Linkitys pitää tehdä uudelleen kirjaston päivityksen yhteydessä, mutta itse käyttöliittymän toiminnallisuuteen ei tarvitse puuttua. Tässäkin mallissa eri sovellusten käyttöliittymät saadaan säilymään yhdenmukaisina pelkästään linkittämällä kaikki sovellukset uudelleen aina käyttöliittymäajurin päivityksen jälkeen.
\cite{w3:xml_v1_0,w3:xhtml,w3:xslt}

\section{Käyttöliittymäajuri}

Tämä kerros vastaa siitä kuinka käyttäjä pystyy tekemään eri valinnat ja toiminnot. Toiminnallisuudessa kuvataan esimerkiksi, että lomakkeella on 10 vaihtoehtoa, joista pitää valita täsmälleen yksi. Tällöin käyttöliittymäajuri voi näyttää sivulla 10 linkkiä, joista käyttäjä painaa yhtä. Vaihtoehtoisesti ajuri voisi näyttää lomakkeen jossa on 10 \alt{radio button} -tyyppistä elementtiä ja OK-painike. Kolmas vaihtoehto olisi näyttää \alt{combobox}-alasvetovalikko yhdistettynä JavaScript-käsittelijään, joka lähettäisi lomakkeen välittömästi käyttäjän näpäytettyä jotain kohtaa. Optimaalisessa tapauksessa käyttöliittymäajuri osaisi käyttää kaikkia näitä vaihtoehtoja ja käyttäjä voisi omissa asetuksissaan valita millä tyylillä hän haluaa käyttää erityyppisiä lomakkeita.

Koska käyttäjä voi haarauttaa istunnon ja siitä ei tule tietoa palvelimelle, täytyy kaikki tieto kuljettaa lomakkeen muun tiedon yhteydessä. Tällöin tieto kahdentuu automaattisesti kun käyttäjä kahdentaa istunnon (avaa uuden ikkunan, jossa on sama sovellus toiminnassa) ja \emph{takaisin}-toiminnon yhteydessä selain käyttää automaattisesti entisen lomakkeen tietoja. Käyttöliittymäajuri ei voi estää vanhentuneen tiedon saapumista\footnote{Käyttäjä voisi esimerkiksi muokata selainkäyttöliittymällä uutisartikkelia, poistaa artikkelin ja käyttää \emph{takaisin} toimintoa ja palata takaisin muokkaukseen. Kun käyttäjä nyt tallentaa tehdyt muokkauset täytyy sovelluksen joko palauttaa poistettu artikkeli tai luoda lähetettyjen tietojen perusteella uusi tai käyttäjän lähettämää tieto hukkuu.}, joten käyttöliittymän toiminnallisuuden tai sovelluslogiikan täytyy ottaa siihen kantaa. Lisäksi istunnon koon täytyy olla pieni, koska sovelluksen generoimien sivujen sisältämien linkkien täytyy myös sisältää istunnon tiedot. HTTP-protokolla määrittelee tavallisten linkkien käyttämän GET-toiminnon maksimidatamääräksi 4 kilotavua ja lisäksi suuri istunto kasvattaa jokaista sivua, sillä osa istuntotiedosta joudutaan toistamaan jokaisen linkin yhteydessä. \cite{ietf:http}

Koska kaikkien sovellusten tietojen lähettäminen jokaisen lomakkeen yhteydessä vaatisi huomattavan lisän tarvittavaan tiedonsiirtokaistaan, tulee ohjelman toteutuksessa erikseen määritellä lomakkeiden kautta siirtyvä tieto, ja tieto joka voidaan jakaa myös haarautettujen tai vanhentuneiden tapahtumien kanssa, jolloin se voidaan säilyttää palvelimella. Lisäksi ajurin rajapinta tulee suunnitella siten, ajuria käyttävää ohjelmaa ei tarvitse muuttaa XForms-tuen yleistyessä. Tavoitteena on, että myöskään ajuria ei tarvitsisi merkittävästi muuttaa, joten käytännössä toteutuksen pitäisi matkia XForms-määritystä niiltä osin kuin se on mahdollista.
\cite{korpela:html_forms,w3:xforms}

Käyttöliittymäajurin täytyy myös yrittää tunnistaa asiakasohjelma (selaintyyppi ja versio) ja kiertää jollakin tavalla siinä tunnetut ongelmat. Viallisten selainten tukeen kuluva työaika on helpompi perustella, koska ajuri on yhteinen monelle eri sovellukselle, joten kustannukset ohjelmaa kohden ovat pienempiä kuin perinteisellä mallilla.

Koska käyttöliittymäajurin täytyy huolehtia kaikista selaimen käytöstä johtuvista ongelmista on sen käytännön toteutus oletettavasti kohtuullisen vaikea. HTML-kieltä tukevan ajurin ei kuitenkaan tarvitse ottaa kantaa käyttöliittymän yksityiskohtiin, ainoastaan eri komponenttien järjestykseen, sillä ulkonäölliset yksityiskohdat voidaan käsitellä asiakkaan ohjelmassa CSS:n avulla \cite{w3:css}. Sovellukselle voidaan helposti tuottaa erilaisia ulkoasuja (\alt{skins}) pelkästään luomalla erilaisia CSS-tiedostoja.


\section{Suunnitelmaa}

\emph{[ Ja taas vuotta viisaampana täytyy todeta, että kyseisen ajurin toteuttaminen oli vieläkin työläämpää kuin ajattelin. Erityisesti siitä saatava hyöty on vähintäänkin kyseenalainen verrattuna täydellisen toteutuksen vaatimaan työmäärään. ]}

Tavoitteenani on tutkia tarkemmin käyttöliittymän toiminnallisuuden erottamista käyttöliittymän käytännön toteutuksesta ja pyrkiä kehittämään PHP-kielellä sovelluskehys, joka sisältää kuvaamani kaltaisen käyttöliittymäajurin. Tiedon tallennus tehdään erillisen ajurin kautta ja tarkoituksena on tukea MySQL ja PostgreSQL -tietokantoja.

Sovelluskehyksen kehittäminen vaikuttaa parhaalta ratkaisulta, koska tällöin käyttöliittymäajurin kehitys saadaan toivottavasti helpommaksi. Lisäksi tällä tavalla sovelluslogiikkaan tulisi mahdollisimman vähän sovelluksen toimintaan liittymätöntä ohjelmakoodia ja uusien sovellusten teko nopeutuisi. Myös lokalisointiin tarvitava logiikka on yhteinen eri sovellusten välillä.

Työ tehdään Koulutuksen tutkimuslaitoksen Peda.net-hankkeelle \cite{pedanet:home} ja toteutuskielenä on PHP, koska myös entiset järjestelmät on toteutettu sillä.

Resurssien lukittamiseen (ja yleisemmin rinnakkaiseen muutosten hallintaan) liittyvä ongelma on vielä ratkaisematta.

Tämän dokumentin sisältö perustuu pitkälti omien kokemusten varaan, enkä ole vielä löytänyt hyvää lähdemateriaalia -- olen pyrkinyt perustamaan päätelmäni World Wide Web Consortiumin (\alt{W3C}, \cite{w3:home}) ja Internet Engineerin Task Forcen (IETF, \cite{ietf:home}) julkaisemiin dokumentteihin.

\chapter{Peda.net -projekti ja -hanke}

Peda.net on vuonna 1995(?) perustetun projektin loppumisen jälkeen hankkeeksi siirtynyt jäsenyhteisö. Peda.net kouluverkko muodostuu jäsenverkostosta, jossa jokainen jäsen (koulu tai kunta) maksaa kiinteän vuosimaksun ja saa vastineeksi rajoittamattoman käyttöoikeuden Peda.net-hankkeen tuottamiin sovelluksiin.


\section{Taustaa}

Internet, ja erityisesti World Wide Web (WWW), on kehittynyt viimeisen kymmenen vuoden aikana olemattomasta ehkä tärkeimmäksi tietolähteeksi ja tiedonjakelukanavaksi. WWW-ympäristössä käytetty HTTP-tiedonsiirtoprokotolla ei ole merkittävästi muuttunut tänä aikana - samoin myös sivujen esityskieli, HyperText Markup Language (HTML), on pääpiirteiltään säilynyt samana. Erityisesti WWW-ympäristössä käytettävissä olevat vuorovaikutuksen mahdollistavat tekniikat ovat käytännössä edelleen samat kuin jo aikoinaan Netscape Navigator 2.0:n julkistuksessa. Tämä historian taakka käytettävien tekniikoiden suhteen vaatii huomioonottamista heti selainkäyttöisen ohjelman suunnittelun aloittamisesta saakka. Liian usein näin ei kuitenkaan ole.



\section{Peda.net-kouluverkko}

Peda.net on Jyväskylän yliopiston Koulutuksen tutkimuslaitoksen koordinoima tutkimus- ja kehittämishanke, joka alkoi projektina vuonna 1996(??). Projektivaihe loppui 2002(??), jonka jälkeen Peda.net on toiminut omarahoitteisena jäseniltä kerättyjen vuosimaksujen turvin. Jäsenet saavat jäsenmaksun vastineena vapaan käyttöoikeuden kaikkiin Peda.net:n sovelluksiin ja pääsevät halutessaan osallistumaan uusien sovellusten kehittämiseen.

Peda.net-kouluverkko toimii Koulutuksen tutkimuslaitoksessa Tietoverkot oppimis- ja työympäristöissä tutkimusryhmän yhteydessä. Tutkimusryhmän tavoitteena on tarkastella teknologian ja virtuaalisten oppimisympäristöjen mahdollisuuksia oppimisen ja opetuksen tukena. Tutkimusryhmän tekemä tutkimus on yhtäältä monitieteistä, teoreettisesti painottunutta perustutkimusta sekä toisaalta käytännöllistä lähtökohdista nousevaa kehittämistutkimusta.

Peda.net kouluverkkoon liittyvä tutkimus on kehittämistutkimusta, joka tapahtuu läheisessä yhteistyössä koulujen ja opettajien kanssa. Eri oppilaitosten ja organisaatioiden henkilöstön lisäksi tutkimusyhteistyössä on mukana myös muita alan kansallisia ja kansainvälisiä asiantutkijoita.

\section{Peda.net:ssä kirjoittajan kehittämiä sovelluksia ja prototyyppejä}

\subsection{Kurssitarjotin (1998?-2000?)}

Kurssitarjotin kehitettiin MiniSQL-tietokantasovelluksen päälle Perl-ohjelmointikielellä. Kurssitarjotin suunniteltiin samannimisen paperilla julkaistun toisen asteen oppilaitosten yhteistyössä järjestämien kurssien sähköiseksi vastineeksi. Sovelluksella pystyi selaamaan tarjolla olevia kursseja ja lähettämään hakemuksia kurssille. Ylläpito-osalla voitiin lisätä, muokata ja poistaa kurssien vastuuhenkilöitä (käytännössä opettajia tai opinto-ohjaajia); lisätä, muokata ja poistaa tarjolla olevia kursseja ja hallita kursseille hakeneita ja liitettyjä opiskelijoita.

Kurssitarjotin kehitettiin siihen aikaa yleiseen tyyliin, jossa ohjelman toiminta ja käyttöliittymän toimintaan liittyvä koodi oli sidottu tiukasti toisiinsa. Lisäksi normaali luku-käyttöliittymä ja ylläpitokäyttöliittymä toimivat omina sovelluksinaan käyttäen yhteistä tietokantaa. Ohjelman ylläpito todettiin hankalaksi ohjelman heikon rakenteen, MiniSQL-tietokannan rajoittuneisuuden ja kokonaisuuden sirpaleisuuden (luku ja ylläpito käyttivät osittain poikkeavia käyttöliittymiä, mikä puolestaan koettiin huonona käytettävyytenä - tämän korjaaminen oli taas työlästä) vuoksi.


\subsection{OPSpro2-prototyyppi (1999?-2000?)}

OPSpro, eli opetussuunnitelmaprosessori, on hajautettu, rakenteisen dokumentin tuottamissovellus. Koska jokaisella koululla tulee olla oma, yksilöllinen opetussuunnitelma, ja toisaalta opetussuunnitelman jokainen osa on parhaimmillaan täysin erilainen osuus (esimerkiksi kuvaus englanninkielen opetuksesta yläasteella) voi dokumentin eri osia kirjoittaa samanaikaisesti usea eri henkilö. OPSpro:n avulla esimerkiksi äidinkielen opettaja voi kirjoittaa ja ylläpitää opetussuunnitelman äidinkielen osuutta samaan aikaan kun matematiikan opettaja vastaavasti ylläpitää omaa osuuttaan. OPSpro huolehtii automaattisesti rakenteen ylläpitämisestä (eli äidinkieli ja englanti ovat koko opintosuunnitelman alilukuja) ja koko dokumentin kokoamisesta (eli dokumentin eri paloja ei tarvitse lähettää esimerkiksi sähköpostilla kokoamisesta vastaavalle henkilölle, joka koostaisi koko dokumentin esimerkiksi MS Word -tekstinkäsittelyohjelmalla. Ohjelman nykyisin (2004) käytössä olevalla versiolla on kirjoitettu ongelmitta yli 500 sivun dokumentteja.

OPSpro ei sinänsä pakota juuri opetussuunnitelman tekemiseen, vaikka osa käyttöliittymässä käytetyistä termeistä siihen suuntaan viittaakin.

Ensimmäinen OPSpro kehitettiin aikoinaan (1997?) Jyväskylän yliopiston tietotekniikan laitoksen Cum Laude -työprojektina(???). Tämän sovelluksen tekninen toteutus todettiin kuitenkin myöhemmin riittämättömäksi. Kirjoittajan tehtäväksi jäi kehittää ideasta parempi versio. Tämä versio jäi loppujen lopuksi prototyypiksi, erityisesti käytetyn ohjelmointikielen ja tietokannan vuoksi: ohjelma toteutettiin Perl-ohjelmointikielellä MiniSQL-tietokannan päälle. Toiminnallisella puolella sovellus pystyi tekemään suuren osan siitä, mitä nykyinenkin versio ja tarjosi enemmän käyttäjän suorittamaa räätälöinnin mahdollisuutta koulukohtaisesti erityisesti käyttöliittymän osalta. Käytännössä käyttöliittymän räätälöinti osoittautui liian vaikeaksi tavalliselle opettajalle tai koulun atk-ylläpitäjälle (joka yleensä on todellisuudessa matemaatiikan tai tietotekniikan opettaja).


\subsection{Verkkoveräjä (Portal) (2000?-)}

Portaalissa eli verkkoveräjässä alkuperäisenä ideana oli tarjota koulun opettajalle mahdollisuus ylläpitää opiskelua tukevaa www-sivua tai sivustoa ilman ohjelmointitaitoa. Yleisempänä käyttötarkoituksena oli tukea myös yleisemmin www-sivujen tuotantoa - esimerkiksi koulun kotisivujen muodossa. Verkkoveräjän yhteydessä www-sivulla tarkoitetaan pelkän tekstin ja kuvien julkaisemisen lisäksi esimerkiksi verkkokeskustelua ja vastaavaa toimintaa. Sivu kootaan ns. moduuleista joita ladotaan käyttöliittymään palstoina. Ideana on, että yksi moduuli tarjoaa yhden toiminon: esimerkiksi kuva-mooduulilla voi sivulle liittää kuvan ja kuvatekstin.

Verkkoveräjä oli viimeinen Peda.net:sssä Perl-ohjelmointikielellä toteutettu ja julkaistu sovellus. Verkkoveräjä toimi MySQL-tietokannan päällä ja nykyisin käytössä oleva, Juha Lahden PHP-ohjelmointikielellä vuonna 2004 kirjoittama versio, käyttää edelleen pääpiirteiltään samaa tietokantaa. Keväällä 2004 verkkoveräjiä oli käytössä n. 13000.


\subsection{Portal2-prototyyppi (2001?-2003?)}

Portaalista eli verkkoveräjästä alettiin tekemään toista versiota, joka eteni täysin toimivan prototyypin toteutukseen asti. Uusi versio tarjosi mahdollisuuden vaikuttaa portaalin ulkonäköön huomattavasti enemmän ja merkittävänä toiminnallisena uutuutena moduuleita voitiin tarjota julkisesti tarjolle, jolloin esimerkiksi yksittäisen opettajan tuottamaa matemaatikan aineistoa voitaisiin käyttää toisen koulun matematiikan kurssilla integroituna muuhun koulun käyttämään materiaaliin. Ohjelmaa tehtiin uuden tietokantarakenteen päälle, mutta myöhemmin päädyttiin tulokseen, että uuden version tarjoamat uudet toiminnot eivät olleet riittävän merkittäviä ja helppokäyttöisiä, että vanhan version käyttäjien olisi kannattanut siirtyä käyttämään uutta versiota. Portal2 tehtiin vielä Perl-ohjelmointikielellä MySQL-tietokannan päälle.

Juha Lahti kirjoitti keväällä 2004 julkaistun kolmannen version. 


\subsection{Yale2-prototyyppi (2002?)}

Yale2 eli Yet Another Learning Environment 2 on kokonaan PHP-ohjelmointikielellä kirjoitettu versio Juha Lahden tekemästä YALE-prototyypistä. Yale2 on selainkäyttöinen oppimisympäristö yksittäisen koulun käyttöön. Yale2 tarjosi suljettujen, oppilaiden käyttöön luotujen kurssien luomisen ja ylläpidon lisäksi julkaisumahdollisuuden "kirjasto"-nimisen ominaisuuden muodossa. Yale2 on tätä kirjoittaessa (keväällä 2004) edelleen pienimuotoisessa testikäytössä, mutta sitä ei tulla virallisesti ottamaan käyttöön missään vaiheessa. Sovellus poistetaan käytöstä todennäköisesti tämän vuoden loppuun mennessä. Yale2 oli loogisesti Peda.net Vihkon esiaste, jossa ei ollut versionhallintaa ja oikeuksien hallinta oli huomattavasti rajoittuneempaa. Lisäksi käyttöliittymän rakenteessa oli joitakin käytettävyysongelmia, mutta pelkästään niiden vuoksi ei olisi kannattanut aloittaa täysin alusta, kuten Vihkon tapauksessa tehtiin.

\subsection{Vihko (kehitysnimi, 2003-2004, käyttöönotto syksyllä 2004)}

Peda.net Vihko on kirjoittajan nykyinen kehitysprojekti joka tarjoaa yksittäiselle koululle riittävän oppimisympäristön. Tämä sovellus ei tue kurssien järjestämistä usean eri oppilaitoksen kesken vaan on suunniteltu yksittäisen koulun tarpeita varten. Ylläpitäjän kannalta merkittäviä ominaisuuksia ovat käyttäjien hallinta monitasoisten ryhmien kautta, kurssien ja kurssimateriaalien oikeuksien määrittely luku- ja kirjoitusoikeuksien avulla ja versionhallinta sekä kaiken materiaalin vapaa linkittäminen mihin tahansa järjestelmän sisällä. Loogisella tasolla vihkossa ylläpidetään kaksisuuntaista hierarkiaa, joka muodostuu erilaisista dokumenttityypeistä tai moduuleista: kansioista, tiedostoista, keskusteluista ja työtiloista. Jokainen moduuli voi sisältää muita moduuleita ja jokainen moduuli voi näkyä monen eri moduulin sisällä. Tietokanta mahdollistaa jopa moduulin näkymisen itsensä sisällä. Osaa toiminnoista on rajoitettu käyttäjän toimien helpottamiseksi.

\subsection{Muu Peda.netissä tapahtunut sovelluskehitys}

Lisäkseni Peda.net-projektissa ja hankkeessa on tehnyt ohjelmistokehitystä Juha Lahti, joka on kehittänyt mm. seuraavat sovellukset:

Verkkolehti (vain prototyyppi, 1998?)
Verkkolehti (Juhan opinnäytetyö?, 2000?)
OPSpro (versio 3+) (2002?)
Verkkoveräjä2 (Portal3, 2004)
Verkkolehti (uusi versio, otetaan käyttöön kesällä 2004)

\section*{Kiitokset}

Matthieu Weber ja Antti-Juhani Kaijanaho ovat tuottaneet \LaTeX{}-luokan Pro Graduja varten, jota myös tämä dokumentti käyttää. Kiitokset heille!

%\cite{refresh} -- REFRESH BIBLIOGRAPHY (Makefile trigger)
%%% Bibliography:
\bibliographystyle{bibtexstyle}
\bibliography{bibliography}

\end{document}
