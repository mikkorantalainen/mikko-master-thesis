\chapter{Selainkäyttöliittymän ongelmia}

\begin{chapterquote}{Keskustelu Matrix-elokuvassa}
Neo: "You mean I can dodge bullets?"\\
Morpheus: "I mean when you are ready, you won't have to."
\end{chapterquote}

Syitä siihen, että esimerkiksi takaisin-toiminnon käyttö rikkoo monia selainkäyttöisiä sovelluksia, täytyy etsiä perinteisen ohjelmistokehityksen malleista. Viimeistään graafisten käyttöliittymien myötä on tullut yleiseksi tapahtumankäsittelijään perustuva käyttöliittymän ohjelmointimalli. Siinä ohjelman tilaa ohjaillaan erilaisilla tapahtumilla (\alt{events}) ja ohjelma toimii aina sen hetkisen \emph{tilan} mukaan.

Esimerkiksi Microsoft Windows -käyttöjärjestelmässä toimiva Microsoft Word -ohjelma on tälläinen. Sen tekijät ovat tehneet oletuksen, että käyttöjärjestelmä ilmoittaa kaikista ohjelmalle tehtävistä asioista tapahtumalla ohjelmalle itselleen. Käyttöjärjestelmä on suunniteltu siten, että kaikista ohjelmaa kiinnostavista tapahtumista todellakin menee tieto ohjelmalle asti ja tapahtumankäsittelijä toimii hyvin. Selainkäyttöiset ohjelmat eivät kuitenkaan toimi tälläisessä ympäristössä.

WWW-sivujen taustalla toimiva HTTP-protokolla ei pidä yhteyttä palvelimeen koko ajan, vaan looginen yhteys\footnote{HTTP 1.1 lisäsi mahdollisuuden pitää varsinainen tietoliikenneyhteys auki eri sivujen hakujen välillä, mutta HTTP-palvelin tai selain voi esimerkiksi vähäisten resurssien vuoksi katkaista yhteyden käyttääkseen siihen käytettyjä resursseja hetkellisesti muualla.} katkeaa välittömästi yksittäisen sivun saamisen jälkeen ja erityisesti selain ei lähetä palvelimelle mitään tietoa takaisin-toiminnon suorittamisesta. Esimerkiksi, jos palvelimella ajetaan yksinkertaiseen tapahtumankäsittelijään perustuvaa sovellusta, saa se ensin tiedon siitä, että käyttäjä haluaa siirtyä johonkin tilaan (esimerkiksi valinta siirtyä sisällysluettelosta lukuun 1.3), mutta sovellukselle ei tule tietoa siitä, että käyttäjä tämän jälkeen palasi takaisin sisällysluetteloon käyttämällä takaisin-toimintoa. Jos käyttäjä tämän jälkeen valitsee sovelluksessa "Muokkaa"-toiminnon, tulee muokkaus sovelluksen tilan perusteella osoittaa lukuun 1.3, mutta käyttäjän mielestä sisällysluetteloon.

Tapahtumien avulla toimiva ohjelmalogiikka ei siis sinänsä ole syyllinen tähän ongelmaan, vaan se, että selainkäyttöinen ohjelma ei voi luottaa siihen, että kaikista asioista syntyisi tapahtuma. Tämän rajoituksen vuoksi perinteisen mallin mukaisesti toteutettu ohjelma toimii epävakaasti selainkäyttöisenä.

\section{Ohjelmakerroksia}

Ohjelmistotuotannossa käyttäjän kanssa vuorovaikutuksessa toimiva ohjelmisto pyritään perinteisesti jakamaan kahteen tai kolmeen kerrokseen. Kaksikerroksisessa mallissa (kuva \ref{fig:2tier}) ohjelman logiikka erotetaan käyttöliittymälogiikasta ja kolmikerroksisessa mallissa (kuva \ref{fig:3tier}) ohjelman logiikka jaetaan vielä sovelluslogiikkaan ja tiedon käsittelyn logiikkaan. Molemmissa malleissa käyttöliittymä pidetään omassa kerroksessaan erityisesti siksi, että vaihtoehtoisen käyttöliittymän rakentaminen olisi mahdollisimman helppoa. Käytännössä käyttöliittymästä vastaava kerros kutsuu melkein kaikkien toimintojen yhteydessä käyttöliittymälogiikkaa ja itse käyttöliittymäkerroksessa on kohtuullisen vähän ohjelmakoodia. Tämän ansiosta ohjelma on yleensä helppo siirtää esimerkiksi toimimaan jonkin toisen grafiikkakirjaston päälle. Kolmikerrosmallissa etuna on helppo siirrettävyys uudelle tallennusmedialle.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=5cm]{kuvat/fig2tier}
\caption{Kaavio kaksikerroksista ohjelma-arkkitehtuurista}
\label{fig:2tier}
\end{center}
\end{figure}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=5cm]{kuvat/fig3tier}
\caption{Kaavio kolmikerroksista ohjelma-arkkitehtuurista}
\label{fig:3tier}
\end{center}
\end{figure}

Verkossa toimivissa eli useinmiten selainkäyttöisissä ohjelmissa eteen tulee perinteisessä mallissa kohtaamattomia ongelmia: käyttöliittymän toiminta on yhteydetön, käyttäjä voi haarauttaa istunnon ja järjestelmä ei voi erottaa verkon virheellistä toimintaa ja käyttäjän hieman tavallisesta poikkeavaa käyttäytymistä toisistaan. Lisäksi eri selainohjelmien toteutuksissa on usein merkittäviä ohjelmavirheitä.

Teknisten ongelmien lisäksi tulee ottaa huomioon myös käyttäjien tottumukset ja selainohjelmien pääasiallinen käyttötarkoitus: www-sivujen selailu. Eri selainohjelmissa on erilaisia erikoistoimintoja tavallisten sivujen selailun nopeuttamiseksi ja tehostamiseksi. Selaimella käytettävien ohjelmien tulisi toimia mahdollisuuksien rajoissa aivan kuin tavallisten www-sivujenkin.

Käsittelen ensin selaimella käytettävien sovellusten toteutukseen liittyviä ongelmia ja kuvaan lopuksi yhden ratkaisumallin verkkosovellusten tekoon. En käsittele yleisesti verkon yli toimivia ohjelmia, joiden käyttöliittymän logiikka kuitenkin suoritetaan natiivisti asiakkaan päässä. Näihin lukeutuvat myös kaikki Java-pohjaiset asiakasohjelmat.

Verkossa toimivissa selainpohjaissa käyttöliittymissä perustavanlaatuinen ongelma on, että HTML on suunniteltu pääasiassa staattisten dokumenttin esittämiseen \cite{w3:html}. Käyttäjäagentit eli selaimet on suunniteltu pääasiassa staattisten sivukokonaisuuksien lukemiseen ja sen vuoksi selaimissa on esimerkiksi \emph{takaisin}-toiminto (\alt{Back}). Lisäksi selaimet käyttävät sivujen tiedonsiirrossa HTTP-protokollaa, jonka seurauksena käyttöliittymät eivät ole koko ajan yhteydessä palvelimen päässä toimivaan sovelluslogiikkaan. Perinteiset käyttöliittymien suunnittelutavat ja toteutusmallit soveltuvat huonosti selainkäyttöiseen käyttöliittymän toteukseen. Esittelen seuraavassa muutamia suurimpia ongelmia, jotka syntyvät pohjalla olevista arkkitehtuurieroista.

\section{Yhteydetön käyttöliittymä}

WWW-selaimet käyttävät tiedon siirtoon HTTP-yhteyttä tai SSL-salattua HTTP-yhteyttä (\alt{HTTPS}). Molemmat näistä yhteysmalleista ovat loogisesti yhteydettömiä, vaikka tehokkuuden vuoksi todelliset toteutukset pitäväkin yhteyden usein auki eri dokumenttien noutamisen välillä. Selain voi milloin tahansa katkaista entisen yhteyden ja luoda uuden, mutta tämä ei saa vaikuttaa ohjelman toimintaan.

Yhteydettömän toiminnan vuoksi käyttöliittymän toiminnot täytyy suunnitella siten, että yhdellä lomakkeella tehtävät toiminnot eivät vaadi ohjelman sisältöön puuttumista ennen seuraavalle lomakkeelle siirtymistä. Ongelma voidaan osittain kiertää käyttämällä JavaScript-skriptikieltä asiakkaan selainohjelmassa, mutta koska verkkoympäristössä asiakasohjelmaan ei voi luottaa\footnote{JavaScript-skriptikielellä voi esimerkiksi tarkistaa onko syötekenttään käyttäjän kirjoittama tieto laskun viitenumero laskemalla onko viitenumeron viimeinen tarkistusnumero oikein. Jos tarkistusnumero ei toimi, näytetään varoitusikkuna ja pyydetään käyttäjää syöttämään tieto uudelleen. Kuitenkin, turvallisuussyistä sama tarkistus täytyy tehdä myös palvelimella (koska muuten pahantahtoinen asiakas voisi muuttaa selaimessa toimivaa JavaScript-ohjelmaa ja lähettää virheellisen numeron järjestelmään).}, täytyy sama sovelluslogiikka olla myös palvelimen päässä. Tästä seuraa, että sama toiminnallisuus täytyy esittää kahdella eri ohjelmointikielellä (JavaScript ja kieli, jolla palvelimen logiikka on tehty). Seurauksena on koko järjestelmän huomattavasti vaikeampi ylläpito, koska eri kielillä tehtyjen toimintojen täytyy vastata toisiaan. 

\section{Ongelmallinen takaisin-painike}

Kuten edellä mainitsin, selaimet on suunniteltu pääasiassa staattisten dokumenttien käyttämiseen. Lisäksi HTTP-protokollan määritys erikseen huomauttaa, että asiakasohjelman historiatietojen käytön ei tarvitse hakea tietoja palvelimelta \cite[kappale 13.13]{ietf:http}. Esimerkkitapaus ongelmatilanteesta on esitetty kuvassa \ref{fig:fork}. Esimerkissä käyttäjä siirtyy ensin sovelluslogiikan luomalle sivulle (lomakkeelle) $A$, valitsee toiminnon $a_1$ ja siirtyy sen seurauksena sivulle $B$. Tämän jälkeen käyttäjä voi käyttää selaimen \emph{takaisin}-toimintoa ja palata takaisin sivulle $A$. Koska tämä on siirtyminen selainohjelman historiatiedoissa, ei asiasta protokollan mukaisesti tarvitse ilmoittaa palvelimelle, joten sovelluslogiikan näkökulmasta asiakas on edelleen sivulla $B$. Tämän jälkeen asiakas valitsee edellisestä poikkevan toiminnon $a_2$. Palvelinohjelman tulee tässä vaiheessa kyetä huomaamaan, että vaikka sen tarjoama lomake olikin $B$, on käyttäjän valitsema toiminto $a_2$ ja toimintoon liittyvä tieto on peräisin lomakkeelta $A$, eikä lomakkeelta $B$.

Usein tähän ongelmaan käytetty ``ratkaisu'' on kertoa käyttäjälle, että sovelluksessa \emph{ei saa} käyttää \emph{takaisin}-toimintoa.\footnote{Tämä rajoitus seuraa yleensä siitä, sovellus yrittää pitää istunnon tilaa yllä. Usein tähän käytetään keksejä (\alt{cookies}). Näiden suurin ongelma on, että niihinkään ei voida helposti vaikuttaa historiatoimintojen yhteydessä ja lisäksi ne ovat globaaleja kaikkien selainohjelman näkymien (ikkunoiden) kesken. Jos istuntoa kuvaavassa keksissä säilytetään myös käyttäjän tunnistetietoja ei sovellukseen voi kirjautua monella eri käyttäjällä samanaikaisesti - paitsi jos käyttää eri selainohjelmaa jokaista käyttäjää kohden!} Olennaista on kuitenkin huomata, että käyttäjä teki tietoisen päätöksen käyttäessään -- tai yrittäessään käyttää -- kyseistä toimintoa ja varmastikin hän olisi halunnut sen tekevän jotain muuta, kuin näyttävän virheilmoituksen. Ohjelma tulee siis tehdä sellaiseksi, että se pystyy vastaanottamaan ja käsittelemään \emph{mahdollisimman suuren} osan käyttäjän lähettämästä tiedosta, vaikka muuttuneen tilanteen vuoksi osa siitä ei olisikaan relevanttia.

\section{Istunnon haarautuminen}

Istunnon haarautuminen liittyy hyvin läheisesti \emph{takaisin}-toimintoon. Siinä erona, käyttäjä kahdentaa aktiivisen lomakkeen $A$ ja valitsee ensimmäisessä ikkunassa toiminnon $a_3$ ja toisessa ikkunassa toiminnon $a_4$. Järjestelmä palauttaa toiminnon $a_3$ seurauksena sivun $C$ ja toiminnon $a_4$ seurauksena sivun $D$. Järjestelmän kannalta tämä tapahtuma näyttää täsmälleen samalta kuin \emph{takaisin}-toiminnon käyttökin, mutta merkittävä ero syntyy siitä, että seuraavaksi käyttäjä voi tuottaa rinnakkaisia tapahtumia sekä lomakkeelle $C$, että lomakkeelle $D$. Ei siis riitä, että palvelinohjelma pitää kirjaa käyttäjän toimintahistoriasta ja osaa peruuttaa lähetettyjen kutsujen mukaan oikeaan tilanteeseen; lisäksi ohjelman pitää kyetä haarauttamaan istuntoja epäsuorien tapahtumien kautta. Täysin oikean istuntoa kuvaavan tiedon ylläpitäminen palvelimella onkin vähintäänkin hyvin työlästä ellei mahdotonta. Istunnon tiedot täytyy siis jotenkin saada siirtymään selainohjelmassa ikkunakohtaisesti, jolloin ikkunan kahdentaminen kahdentaa myös istunnon.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=14cm]{kuvat/fork}
\caption{Kaavio istunnon haarautumisesta}
\label{fig:fork}
\end{center}
\end{figure}

\section{Verkon virheiden havaitseminen mahdotonta}

Yhteydettömästä käyttäliittymästä seuraa myös, että palvelin ei voi tunnistaa verkon virheellistä toimintaa asiakkaan selaimen sulkemisesta tai asiakkaan tietokoneen jumiutumisesta. Yllämainitut ongelmatilanteet  näkyvät palveliohjelmalle vastaavasti kuin asiakas vain käyttäisi epätavallisen kauan aikaa lomakkeen täyttämiseen. Tämän vuoksi mikään toiminto ei saisi lukittaa resursseja siihen asti kunnes ``käyttäjän istunto loppuu.'' Käytännössä tälläisia resurssien lukittamisia kuitenkin tarvitaan ja usein ratkaisuna on käyttää maksimiaikaa lukitukselle; kun käyttäjä valitsee esimerkiksi uutisartikkelin muokkauksen, merkitään muokattava artikkeli lukituksi, jolloin muut eivät voi sitä muokata. Lukitus puretaan kun käyttäjä tallentaa muokatun artikkelin tai kun ennaltamäärätty maksimiaika lukitukselle on kulunut.

\section{Selainten virheelliset toteutukset}

Kun palvelimen ohjelmisto on saatu toimimaan ja kaikki edellämainitut ongelmat on otettu huomioon, havaitaan, että eri selainohjelmat eivät toimi eri standardeissa määrätyllä tavalla. Useimmat vioista vaikuttavat ainoastaan käyttäjälle näkyvän lomakkeen ulkoasuun -- esimerkiksi joku teksti on suhteessa muuhun käyttöliittymään suuremmalla tekstillä kuin pitäisi. Kuitenkin osa vioista voi estää tiettyjen toimintojen käytön: esimerkiksi HTML-määrityksen mukaan yhden \code{file}-tyyppisen lomake-elemntin tulee tarjota mahdollisuus usean tiedoston siirtämiseen yhtä aikaa. Ainoa yleisesti käytössä oleva selain, joka toimii tässä mielessä määrityksen mukaisesti, on \emph{Opera}. Tämä näkyy myös yleisimmissä palvelinpään toteutuksissa siten, että Operalla monta tiedostoa yhtä aikaa lähetettäessä, tapahtuus palvelinpäässä yleensä virhe tiedostoja vastaanotettaessa, koska palvelinohjelmiston kehittäjä ei ole lukenut määritystä vaan ainoastaan tarkkaillut kuinka yleisimmät selaimet toimivat.
\cite{korpela:file_input}

Toinen yleinen virhe selainten toteutuksessa on tiedon lähettäminen UTF-8 koodauksella ilman siitä ilmoittamista -- protokollan mukaan oletuksena tulee tällöin käyttää ISO-8859-1-merkistöä jonka seurauksena kaikki ASCII-merkistön ulkopuoliset merkit siirretään väärin. Tässä siis puutteellisen toiminnan lisäksi tuhoutuu myös tietoa. Tämä ongelma voidaan kiertää lähettämällä lomakkella näkymätön kenttä, jonka sisältö on tunnettu ja sisältää ASCII-merkistön ulkopuolisia merkkejä, ja tarkastelemalla kuinka selain koodaa tämän kentän sisällön.
