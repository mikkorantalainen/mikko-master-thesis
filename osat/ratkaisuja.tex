\chapter{Eräs ratkaisumalli selainkäyttöliittymän toteutukseen}

\begin{chapterquote}{Keskustelu Matrix-elokuvassa}
Neo: "You mean I can dodge bullets?"\\
Morpheus: "I mean when you are ready, you won't have to."
\end{chapterquote}

Kuten luvussa \ref{ongelmia} kuvasin, selainkäyttöisten ohjelmien käyttöliittymien toteuttamisessa on useita ongelmia. Kuvailen tässä luvussa ratkaisuvaihtoehtoja tuossa luvussa kuvattujen ongelmien ratkaisemiseksi. Osa suunnittelemistani ratkaisuvaihtoehdoista osoittautui epäkäytännöllisiksi, mutta kuvailen ne siitä huolimatta antamaan kuvaa ratkaisujen kehityskaaresta.

\section{Lisää kerroksia}

Ensimmäisenä ajatuksena oli jakaa luvussa \ref{tiers} kuvattu kolmikerroksinen malli vielä kerran, päätyen nelikerroksiseen rakenteeseen. Tässä mallissa käyttöliittymäkerros jaetaan käyttöliittymän toiminnallisuuden kuvaamiseen ja käyttöliittymäajuriin (kuva \ref{fig:4tier}).

\begin{figure}[htb]
\begin{center}
\includegraphics[width=10cm]{kuvat/fig4tier}
\caption{Kaavio nelikerroksista arkkitehtuurista usean sovelluksen tapauksessa}
\label{fig:4tier}
\end{center}
\end{figure}

Jaon etuna eri sovellusten käyttöliittymät saadaan toimimaan vastaavalla ulkonäöllä ja mahdollisimman pitkälti vastaavilla toiminnoilla. Tämä onnistuu jakamalla käyttöliittymäajuri eri sovellusten kesken. Suunnittelemalla käyttöliittymän toiminnallisuuden ja käyttöliittymäajurin rajapinta sopivasti, helpottuu käyttöliittymän kirjoittaminen verrattuna entiseen malliin, jossa käyttöliittymää kirjoitettaessa jouduttiin kirjoittamaan koodi myös käyttöliittymän eri osien, kuten erilaisten painikkeiden, hallintaan. Uudessa mallissa käyttöliittymän kuvauksessa vain ilmoitetaan, että käyttäjän tulee valita annetusta listasta kaksi tai kolme kohtaa. Käyttöliittymäajuri voisi sitten toteuttaa tuon esityksen esimerkiksi ryhmällä \alt{radio button} -tyyppisiä grafiikkaelementtejä tai vaihtoehtoisesti valintalaatikon (\alt{select box}) avulla. WWW-käytössä käyttöliittymäajurin muodostamaa lopputulosta voitaisiin vielä hioa kirjoittamalla lomakekohtaisia ulkonäköasetuksia CSS-kielellä \cite{w3:css}.

Käyttöliittymäajuri keskustelee www-selaimen kanssa, mutta vaihtoehtoisesti sen voisi toteuttaa natiivilla sovelluksella. Tällöin edes ohjelman käyttöliittymän kuvausta ei tarvitsisi muuttaa vaikka käyttöympäristö vaihtuisi selainkäyttöisestä natiiviksi. Koska toiminnallisuuden täytyy kuitenkin olla lomakepohjainen toimiakseen \emph{hyvin} selaimen kautta, ei tällainen natiivikäyttöliittymä olisi merkittävästi parempi kuin selainpohjainen käyttöliittymäkään. Väitänkin, että selainkäyttöisten ohjelmien käyttöliittymien logiikka ja dialogien rakenne pitääkin suunnitella eri tavalla kuin perinteisten, käyttöjärjestelmän omien sääntöjen mukaan toimivien sovellusten.

\subsection{Tiedon käsittelyn logiikka}

Tämä kerros toteutetaan käyttämällä jotain olemassaolevaa tietokantaa, esimerkiksi MySQL tai PostgreSQL. Teoriassa tietokannan pitäisi ymmärtää ja valvoa kaikki tiedon esitysmalliin liittyvät rajoitukset, mutta koska tietokantoja käsitellään käytännössä aina SQL-kielen avulla, ei riippuvuustietoja voida kattavasti esittää tietokantavalmistajasta riippumattomalla tavalla. Jos ohjelmasta halutaan siirrettävä, jolloin sitä voidaan käyttää monen eri tietokantaohjelmiston kanssa, täytyy melkein kaikki tarkistukset tehdä sovelluslogiikassa. Tietokannan tehokkuus voidaan maksimoida ohjelmoimalla tarkistukset ja rajoitukset tietokannan omilla työkaluilla, mutta siirrettävyys menetetään. Pyrin itse pitämään selainkäyttöiset sovellukset tietokantariippumattomina, koska olen kokenut, että käytännössä eri tietokannan käyttämisestä saatava nopeusero on suurempi kuin yksittäisen tietokannan hienosäätämisestä saatava nopeusero. Eli pitkällä aikavälillä suurin nopeuden kasvattaminen saataisiin aikaiseksi vaihtamalla tietokantaa aina sen hetkisen sisällön ja käyttöprofiilin mukaisesti nopeiten toimivaan.
Koska tietokantasovelluksissakin on virheitä, ei tällaisesta tietokannasta toiseen siirtymistä voi kuitenkaan kovin usein suositella. Tämän tutkielman kannalta tarkka jako ei ole olennaista.

\subsection{Sovelluslogiikka}

Sovelluslogiikka vastaa sovelluksen ``älystä''. Teoriassa tässä kerroksessa ei oteta mitään kantaa sovelluksen käyttöliittymään. Käytännössä tämä kerros on todennäköisesti tehokkainta sulauttaa osittain käyttöliittymän toiminnallisuuden kanssa. Näin sen vuoksi, että sovelluslogiikkaan ei yleensä ohjelmoida ominaisuuksia, joita käyttöliittymän toiminnallisuus ei tarvitse. Toisaalta käyttöliittymään ei voida lisätä ominaisuuksia, joita sovelluslogiikka ei voi tukea. Eli kaikki muutokset täytyy kuitenkin tehdä molempiin osiin! Lisäksi sulauttamisen haittojen voi neljän kerroksen mallissa olettaa olevan kohtuullisen pieniä, koska käyttöliittymän toiminnallisuus ei ole enää niin tiukasti sidottu itse käyttöliittymän ulkonäköön.

\subsection{Käyttöliittymän toiminnallisuus}

Käyttöliittymän toiminnallisuudesta vastaava kerros kuvaa käyttöliittymän toiminnan abstraktilla tavalla: ``tästä taulukosta täytyy valita 2-5 riviä'' tai ``käyttäjän tulee syöttää lomakkeelle kaksi merkkijonoa. Näiden merkkijonojen nimet ja tyypit ovat 'käyttäjätunnus':merkkijono ja 'salasana':salattu merkkijono.'' Tämä kerros ei ota kantaa siihen missä järjestyksessä taulukon sarakkeet ja rivit näytetään tai siihen, syötetäänkö käyttäjätunnus tekstikenttään vai napauttelemalla hiirellä jonkin kuvan eri kohtia.

Teoriassa tämä kerros voisi generoida yksinkertaisen XML-sivun, joka muutettaisiin XHTML tai HTML -sivuksi selaimen toimintoja varten. Tällöin käyttöliittymäajurin voisi kirjoittaa esimerkiksi XSLT-kielellä. Käytännössä tällaisen ajurin kirjoittaminen muodostuu oletettavasti niin hankalaksi, että paremmalta vaihtoehdolta tuntuu kirjoittaa käyttöliittymäajuri kirjastoksi, joka linkitetään\footnote{Joissakin ohjelmointiympäristöissä ohjelmakoodi käännetään objektitiedostoiksi, jotka yhdistetään \emph{linkittämällä} valmiin ohjelman tuottamiseksi. Vasta näin tuotettu valmis ohjelma voidaan suorittaa. Toisaalta, esimerkiksi PHP-kielisissä ohjelmissa manuaalinen linkitys ei ole tarpeen, sillä se suoritetaan automaattisesti ohjelman käynnistyessä.} ohjelmaan sitä tehtäessä. Linkitys pitää tehdä uudelleen kirjaston päivityksen yhteydessä, mutta itse käyttöliittymän toiminnallisuuteen ei tarvitse puuttua. Tässäkin mallissa eri sovellusten käyttöliittymät saadaan säilymään yhdenmukaisina pelkästään linkittämällä kaikki sovellukset uudelleen aina käyttöliittymäajurin päivityksen jälkeen.
\cite{w3:xml_v1_0,w3:xhtml,w3:xslt}

\subsection{Käyttöliittymäajuri}

Tämä kerros vastaa siitä kuinka käyttäjä pystyy tekemään eri valinnat ja toiminnot. Jos, käyttöliittymässä on kuvattu, että lomakkeella on 10 vaihtoehtoa, joista pitää valita täsmälleen yksi, niin tällöin selainkäyttöisen sovelluksen käyttöliittymäajuri voi näyttää sivulla 10 linkkiä, joista käyttäjä painaa yhtä. Vaihtoehtoisesti ajuri voisi näyttää lomakkeen jossa on 10 \alt{radio button} -tyyppistä elementtiä ja OK-painike. Kolmas vaihtoehto olisi näyttää \alt{combobox}-alasvetovalikko yhdistettynä JavaScript-käsittelijään, joka lähettäisi lomakkeen välittömästi käyttäjän näpäytettyä jotain kohtaa. Optimaalisessa tapauksessa käyttöliittymäajuri osaisi käyttää kaikkia näitä vaihtoehtoja ja käyttäjä voisi omissa asetuksissaan valita millä tyylillä hän haluaa käyttää erityyppisiä lomakkeita.

Koska selainkäyttöisen sovelluksen käyttäjä voi haarauttaa istunnon ja tästä toiminnosta ei synny tapahtumaa palvelimelle, täytyy kaikki tieto kuljettaa lomakkeen muun tiedon yhteydessä. Tällöin tieto kahdentuu automaattisesti kun käyttäjä kahdentaa istunnon (avaa uuden ikkunan, jossa on sama sovellus toiminnassa) ja \emph{takaisin}-toiminnon yhteydessä selain käyttää automaattisesti entisen lomakkeen tietoja, sillä nuo tiedot sisältyy siihen sivuun, jota selain käyttää sivun näyttämiseen. Käyttöliittymäajuri ei voi estää vanhentuneen tiedon saapumista\footnote{Käyttäjä voisi esimerkiksi muokata selainkäyttöliittymällä uutisartikkelia, poistaa artikkelin ja käyttää \emph{takaisin} toimintoa ja palata takaisin muokkaukseen. Kun käyttäjä nyt tallentaa tehdyt muokkaukset täytyy sovelluksen joko palauttaa poistettu artikkeli tai luoda lähetettyjen tietojen perusteella uusi tai käyttäjän lähettämää tieto hukkuu.}, joten käyttöliittymän toiminnallisuuden tai sovelluslogiikan täytyy ottaa siihen kantaa. Lisäksi istunnon koon täytyy olla pieni, koska sovelluksen generoimien sivujen sisältämien linkkien täytyy myös sisältää istunnon tiedot\footnote{WWW-sivulla olevat linkit käyttävät aina GET-metodia HTTP-yhteyksiä käytettäessä, jossa kaikki linkin parametrit pitää siirtää tekstinä osoitteen lopussa. Istuntoon liittyvät tiedot täytyy siis toistaa sivun \emph{jokaisen} linkin lopussa ja sivu kasvaa huomattavan nopeasti linkkien lukumäärän mukaan jos istunto-tietoa on paljon.}. HTTP-protokolla määrittelee tavallisten linkkien käyttämän GET-toiminnon maksimidatamääräksi 4 kilotavua ja lisäksi suuri istunto kasvattaa jokaista sivua, sillä osa istuntotiedosta joudutaan toistamaan jokaisen linkin yhteydessä. \cite{ietf:http}

Koska \emph{kaikkien} sovellusten tietojen lähettäminen jokaisen lomakkeen yhteydessä vaatisi huomattavan lisän tarvittavaan tiedonsiirtokaistaan, tulee ohjelman toteutuksessa erikseen jakaa istunto-tiedot kahteen osaan: lomakkeiden kautta siirtyvä tieto, ja tieto joka voidaan jakaa myös haarautettujen tai vanhentuneiden tapahtumien kanssa. Tällöin jaettu tieto voidaan säilyttää palvelimella. Tällaista jaettua tietoa olisivat esimerkiksi käyttäjän henkilökohtaiset asetukset, jotka voidaan jakaa eri ikkunoiden kesken. Esimerkiksi valittu sivuston tyyli tai päivämäärien esitysmuoto olisi tällaista tietoa. Istuntotietoa olisi taas esimerkiksi tieto siitä, mitä toimintoja käyttäjä käytti saapuessaan nykyiseen näkymään, jos tätä tietoa tarvitaan tulevaisuudessa.

Tulevaisuudessa selainkäyttöisen sovelluksen käyttöliittymäajuri voisi tuottaa XForms-määrityksen mukaisia lomakkeita, jolloin käyttöliittymän toiminnallisuus ja ulkonäkö voidaan pitää erillään www-selaimeen asti. Ikävä kyllä XForms on hyvin heikosti tuettu nykyisissäkin selaimissa ja mikään ei viittaa siihen, että tilanteeseen olisi tulossa nopeasti muutosta.
\cite{korpela:html_forms,w3:xforms}

\subsection{Huomioita käyttöliittymäajurin toteuttamiseen liittyen}

Käyttöliittymäajurin täytyy yrittää tunnistaa asiakasohjelma (selaintyyppi ja versio) ja kiertää jollakin tavalla siinä tunnetut ongelmat. Viallisten selainten tukeen kuluva työaika on helpompi perustella, koska ajuri on yhteinen monelle eri sovellukselle, joten kustannukset ohjelmaa kohden ovat pienempiä kuin perinteisellä mallilla.

Koska käyttöliittymäajurin täytyy huolehtia kaikista selaimen käytöstä johtuvista ongelmista, on sen toteuttaminen vaikeaa. HTML-kieltä tukevan ajurin ei kuitenkaan tarvitse ottaa kantaa käyttöliittymän yksityiskohtiin, ainoastaan eri komponenttien järjestykseen, sillä ulkonäölliset yksityiskohdat voidaan käsitellä asiakkaan ohjelmassa CSS-kielen avulla \cite{w3:css}. Sovellukselle voidaan helposti tuottaa erilaisia ulkoasuja (\alt{skins}) pelkästään luomalla erilaisia CSS-tiedostoja.

\section{Nelikerroksisen mallin käytännön ongelmia}

** tähän juttua, miksi en käyttänyt tätä mallia loppujen lopuksi **

\emph{[ Ja taas vuotta viisaampana täytyy todeta, että kyseisen ajurin toteuttaminen oli vieläkin työläämpää kuin ajattelin. Erityisesti siitä saatava hyöty on vähintäänkin kyseenalainen verrattuna täydellisen toteutuksen vaatimaan työmäärään. ]}

Tavoitteenani on tutkia tarkemmin käyttöliittymän toiminnallisuuden erottamista käyttöliittymän käytännön toteutuksesta ja pyrkiä kehittämään PHP-kielellä sovelluskehys, joka sisältää kuvaamani kaltaisen käyttöliittymäajurin. Tiedon tallennus tehdään erillisen ajurin kautta ja tarkoituksena on tukea MySQL ja PostgreSQL -tietokantoja.

Sovelluskehyksen kehittäminen vaikuttaa parhaalta ratkaisulta, koska tällöin käyttöliittymäajurin kehitys saadaan toivottavasti helpommaksi. Lisäksi tällä tavalla sovelluslogiikkaan tulisi mahdollisimman vähän sovelluksen toimintaan liittymätöntä ohjelmakoodia ja uusien sovellusten teko nopeutuisi. Myös lokalisointiin tarvittava logiikka on yhteinen eri sovellusten välillä.

Työ tehdään Koulutuksen tutkimuslaitoksen Peda.net-hankkeelle \cite{pedanet:home} ja toteutuskielenä on PHP, koska myös entiset järjestelmät on toteutettu sillä.

Resurssien lukittamiseen (ja yleisemmin rinnakkaiseen muutosten hallintaan) liittyvä ongelma on vielä ratkaisematta.

Tämän dokumentin sisältö perustuu pitkälti omien kokemusten varaan, enkä ole vielä löytänyt hyvää lähdemateriaalia -- olen pyrkinyt perustamaan päätelmäni World Wide Web Consortiumin (\alt{W3C}, \cite{w3:home}) ja Internet Engineering Task Forcen (IETF, \cite{ietf:home}) julkaisemiin dokumentteihin.
