\chapter{Ratkaisuja selainkäyttöliittymän toteutukseen}

\begin{chapterquote}{Keskustelu Matrix"-elokuvassa}
Neo: "You mean I can dodge bullets?"\\
Morpheus: "I mean when you are ready, you won't have to."
\end{chapterquote}

Kuten luvussa \ref{ongelmia} kuvasin, selainkäyttöisten ohjelmien
käyttöliittymien toteuttamisessa on useita ongelmia. Kuvailen tässä
luvussa ratkaisuvaihtoehtoja tuossa luvussa kuvattujen ongelmien
ratkaisemiseksi. Osa suunnittelemistani ratkaisuvaihtoehdoista
osoittautui epäkäytännöllisiksi, mutta kuvailen ne siitä huolimatta
antamaan kuvaa ratkaisujen kehityskaaresta.

\section{Käyttöliittymäkerroksen jakaminen osiin}

Ensimmäisenä ajatuksena oli jakaa luvussa \ref{tiers} kuvattu
kolmikerroksinen malli vielä kerran, päätyen nelikerroksiseen
rakenteeseen. Tässä mallissa käyttöliittymäkerros jaetaan
käyttöliittymän toiminnallisuuden kuvaamiseen ja käyttöliittymäajuriin
(kuva \ref{fig:4tier}).

\begin{figure}[htb]
\begin{center}
\includegraphics[width=10cm]{kuvat/fig4tier}
\caption{Kaavio nelikerroksista arkkitehtuurista usean sovelluksen
tapauksessa}
\label{fig:4tier}

\end{center}
\end{figure}

Jaon etuna eri sovellusten käyttöliittymät saadaan toimimaan
vastaavalla ulkonäöllä ja mahdollisimman pitkälti vastaavilla
toiminnoilla. Tämä onnistuu jakamalla käyttöliittymäajuri eri
sovellusten kesken. Suunnittelemalla käyttöliittymän toiminnallisuuden
ja käyttöliittymäajurin rajapinta sopivasti, helpottuu käyttöliittymän
kirjoittaminen verrattuna entiseen malliin, jossa käyttöliittymää
kirjoitettaessa jouduttiin kirjoittamaan koodi myös käyttöliittymän eri
osien, kuten erilaisten painikkeiden, hallintaan. Uudessa mallissa
käyttöliittymän kuvauksessa vain ilmoitetaan, että käyttäjän tulee
valita annetusta listasta kaksi tai kolme kohtaa. Käyttöliittymäajuri
voisi sitten toteuttaa tuon esityksen esimerkiksi ryhmällä \alt{radio
button} "=tyyppisiä grafiikkaelementtejä tai vaihtoehtoisesti
valintalaatikon (\alt{select box}) avulla. WWW"-käytössä
käyttöliittymäajurin muodostamaa lopputulosta voitaisiin vielä hioa
kirjoittamalla lomakekohtaisia ulkonäköasetuksia CSS"-kielellä
\cite{w3:css}.

Käyttöliittymäajuri keskustelee www"-selaimen kanssa, mutta
vaihtoehtoisesti sen voisi toteuttaa natiivilla sovelluksella. Tällöin
edes ohjelman käyttöliittymän kuvausta ei tarvitsisi muuttaa vaikka
käyttöympäristö vaihtuisi selainkäyttöisestä natiiviksi. Koska
toiminnallisuuden täytyy kuitenkin olla lomakepohjainen toimiakseen
\emph{hyvin} selaimen kautta, ei tällainen natiivikäyttöliittymä olisi
merkittävästi parempi kuin selainpohjainen käyttöliittymäkään.
Väitänkin, että selainkäyttöisten ohjelmien käyttöliittymien logiikka
ja dialogien rakenne pitääkin suunnitella eri tavalla kuin
perinteisten, käyttöjärjestelmän omien sääntöjen mukaan toimivien
sovellusten.

\subsection{Tiedon käsittelyn logiikka}

Tämä kerros toteutetaan käyttämällä jotain olemassaolevaa tietokantaa,
esimerkiksi MySQL tai PostgreSQL. Teoriassa tietokannan pitäisi
ymmärtää ja valvoa kaikki tiedon esitysmalliin liittyvät rajoitukset.
Käytännössä tähän ei päästä, koska rajanpinta tiedon käsittelyn
logiikan ja sovelluslogiikan välillä on toteutettu SQL"-kielellä. Monien
tietokantojen tuki SQL"-kielelle on varsin kehittymätön erityisesti
tietorakenteen rajoitusten suhteen. Tämän seurauksena merkittävä osa
tiedon esitysmallin rajoituksista joudutaan sijoittamaan
sovelluslogiikkaan. Muuten sovellusta ei voida tulevaisuudessa siirtää
toimimaan toisen tietokannan päällä. Jos siirrettävyys ei ole
tavoitteena, tietokannan tehokkuus voidaan maksimoida ohjelmoimalla
tarkistukset ja rajoitukset tietokannan omilla työkaluilla. Pyrin itse
pitämään selainkäyttöiset sovellukset tietokantariippumattomina -- eli
sijoitan rajoitukset sovelluslogiikkaan -- koska olen kokenut, että
käytännössä eri tietokannan käyttämisestä saatava nopeusero on suurempi
kuin yksittäisen tietokannan hienosäätämisestä saatava nopeusero.
Toisin sanoen, suurin nopeuden kasvattaminen saataisiin aikaiseksi
vaihtamalla tietokantaa aina sen hetkisen sisällön ja käyttöprofiilin
mukaisesti nopeiten toimivaan. Tämän tutkielman kannalta tarkka jako
tiedon käsittelyn logiikan ja sovelluslogiikan välillä ei ole
kuitenkaan olennaista.

\subsection{Sovelluslogiikka}

Sovelluslogiikka vastaa sovelluksen ``älystä''. Teoriassa tässä
kerroksessa ei oteta mitään kantaa sovelluksen käyttöliittymään.
Käytännössä tämä kerros on todennäköisesti tehokkainta sulauttaa
osittain käyttöliittymän toiminnallisuuden kanssa. Näin sen vuoksi,
että sovelluslogiikkaan ei yleensä ohjelmoida ominaisuuksia, joita
käyttöliittymän toiminnallisuus ei tarvitse. Toisaalta käyttöliittymään
ei voida lisätä ominaisuuksia, joita sovelluslogiikka ei tue. Eli
kaikki muutokset täytyy kuitenkin tehdä molempiin osiin, jonka vuoksi
jaosta ei saada kovin paljon etua. Lisäksi sulauttamisen haittojen voi
neljän kerroksen mallissa olettaa olevan kohtuullisen pieniä, koska
käyttöliittymän toiminnallisuus ei ole enää tiukasti sidottu itse
käyttöliittymän ulkonäköön.

\subsection{Käyttöliittymän toiminnallisuus}

Käyttöliittymän toiminnallisuudesta vastaava kerros kuvaa
käyttöliittymän toiminnan abstraktilla tavalla: ``tästä taulukosta
täytyy valita 2--5 riviä'' tai ``käyttäjän tulee syöttää lomakkeelle
kaksi merkkijonoa. Näiden merkkijonojen nimet ja tyypit ovat
`käyttäjätunnus':merkkijono ja `salasana':salattu merkkijono.'' Tämä
kerros ei ota kantaa siihen missä järjestyksessä taulukon sarakkeet ja
rivit näytetään tai siihen, syötetäänkö käyttäjätunnus tekstikenttään
vai vaikkapa napauttelemalla hiirellä jonkin kuvan eri kohtia.

Teoriassa tämä kerros voisi generoida yksinkertaisen XML"-sivun, joka
muutettaisiin XHTML tai HTML "=sivuksi selaimen toimintoja varten.
Tällöin käyttöliittymäajurin voisi kirjoittaa esimerkiksi
XSLT"-kielellä. Käytännössä tällaisen ajurin kirjoittaminen muodostuu
oletettavasti niin hankalaksi, että paremmalta vaihtoehdolta tuntuu
kirjoittaa käyttöliittymäajuri kirjastoksi, joka
linkitetään\footnote{Joissakin ohjelmointiympäristöissä ohjelmakoodi
käännetään objektitiedostoiksi, jotka yhdistetään \emph{linkittämällä}
valmiin ohjelman tuottamiseksi. Vasta näin tuotettu valmis ohjelma
voidaan suorittaa. Toisaalta, esimerkiksi PHP"-kielisissä ohjelmissa
manuaalinen linkitys ei ole tarpeen, sillä se suoritetaan
automaattisesti ohjelman käynnistyessä kun kirjastoa on muutettu.}
ohjelmaan sitä tehtäessä. Linkitys pitää tehdä uudelleen kirjaston
päivityksen yhteydessä, mutta itse käyttöliittymän toiminnallisuuteen
ei tarvitse puuttua. Tässäkin mallissa eri sovellusten käyttöliittymät
saadaan säilymään yhdenmukaisina pelkästään linkittämällä kaikki
sovellukset uudelleen aina käyttöliittymäajurin päivityksen jälkeen.
\cite{w3:xml_v1_0,w3:xhtml,w3:xslt}

\subsection{Käyttöliittymäajuri}

Tämä kerros vastaa siitä kuinka käyttäjä pystyy tekemään eri valinnat
ja toiminnot. Jos, käyttöliittymässä on kuvattu, että lomakkeella on 10
vaihtoehtoa, joista pitää valita täsmälleen yksi, niin tällöin
selainkäyttöisen sovelluksen käyttöliittymäajuri voi näyttää sivulla 10
linkkiä, joista käyttäjä painaa yhtä. \emph{Vaihtoehtoisesti} ajuri
voisi näyttää lomakkeen jossa on 10 \alt{radio button} "=tyyppistä
elementtiä ja OK"-painike. Kolmas vaihtoehto olisi näyttää
\alt{combobox}"-alasvetovalikko yhdistettynä JavaScript"-käsittelijään,
joka lähettäisi lomakkeen välittömästi käyttäjän näpäytettyä jotain
kohtaa. Optimaalisessa tapauksessa käyttöliittymäajuri osaisi käyttää
kaikkia näitä vaihtoehtoja ja käyttäjä voisi omissa asetuksissaan
valita millä tyylillä hän haluaa käyttää erityyppisiä lomakkeita.

\subsection{Käyttöliittymäajurille jää paljon vastuuta}
\label{kaikki-data-sivulla}

Koska selainkäyttöisen sovelluksen käyttäjä voi esimerkiksi haarauttaa
istunnon ja tästä toiminnosta ei synny tapahtumaa palvelimelle, täytyy
kaikki tieto kuljettaa lomakkeen muun tiedon yhteydessä sivuun
upotettuna. Tällöin tieto kahdentuu automaattisesti, kun käyttäjä
kahdentaa istunnon eli käytännössä avaa uuden ikkunan, jossa on sama
sovellus toiminnassa. Samoin historiatoimintojen yhteydessä selain
käyttää automaattisesti entisen lomakkeen tietoja, sillä nuo tiedot
sisältyvät siihen sivuun, jota selain käyttää sivun näyttämiseenkin.
Käyttöliittymäajuri ei voi estää vanhentuneen tiedon saapumista, joten
käyttöliittymän toiminnallisuuden tai sovelluslogiikan täytyy ottaa
siihen kantaa.\footnote{Käyttäjä voisi esimerkiksi muokata
selainkäyttöliittymällä uutisartikkelia, poistaa artikkelin ja käyttää
\emph{takaisin} toimintoa palatakseen takaisin muokkaus"-toimintoon. Kun
käyttäjä nyt tallentaa tehdyt muokkaukset täytyy sovelluksen joko
palauttaa poistettu artikkeli tai luoda lähetettyjen tietojen
perusteella uusi tai käyttäjän lähettämää tieto hukkuu.}

Istunnon ylläpitoon tarvittavan tiedon määrän täytyy olla pieni, koska
kaikkien sovelluksen generoimien sivujen sisältämien linkkien täytyy
sisältää myös istunnon tiedot.\footnote{WWW"-sivulla olevat linkit
käyttävät aina GET"-metodia HTTP"-yhteyksiä käytettäessä, jossa kaikki
linkin parametrit pitää siirtää tekstinä osoitteen lopussa. Istuntoon
liittyvät tiedot täytyy siis toistaa sivun \emph{jokaisen} linkin
lopussa ja sivu kasvaa huomattavan nopeasti linkkien lukumäärän mukaan
jos istunto"-tietoa on paljon.} HTTP"-protokolla määrittelee
tavallisten linkkien käyttämän GET"-toiminnon maksimidatamääräksi neljä
kilotavua, joka asettaa ylärajan istunnon koolle.
\cite{ietf:http}

Koska \emph{kaikkien} sovellusten tietojen lähettäminen jokaisen
lomakkeen yhteydessä vaatisi huomattavan lisän tarvittavaan
tiedonsiirtokaistaan, tulee ohjelman toteutuksessa erikseen jakaa
istunto"-tiedot kahteen osaan: lomakkeiden kautta siirtyvä tieto, ja
tieto, joka voidaan jakaa myös haarautettujen tai vanhentuneiden
tapahtumien kanssa. Tällöin jaettu tieto voidaan säilyttää
palvelimella. Tällaista jaettua tietoa olisivat esimerkiksi käyttäjän
henkilökohtaiset asetukset, jotka voidaan jakaa eri ikkunoiden kesken.
Esimerkiksi valittu koko sivuston tyyli tai päivämäärien esitysmuoto
olisi tällaista tietoa. Jakamatonta istuntotietoa olisi taas
esimerkiksi tieto siitä, mitä toimintoja käyttäjä käytti saapuessaan
nykyiseen näkymään, jos tätä tietoa tarvitaan tulevaisuudessa.

Tulevaisuudessa selainkäyttöisen sovelluksen käyttöliittymäajuri voisi
esittää käyttöliittymän XForms"-määrityksen mukaisilla lomakkeilla,
jolloin käyttöliittymän toiminnallisuus ja ulkonäkö voidaan pitää
erillään www"-selaimeen asti. Ikävä kyllä XForms on hyvin heikosti
tuettu uusimmissakin selaimissa ja mikään ei viittaa siihen, että
tilanteeseen olisi tulossa nopeasti muutosta.
\cite{korpela:html_forms,w3:xforms}

\subsection{Huomioita käyttöliittymäajurin toteuttamiseen liittyen}

Koska eri selaimissa on erilaisia vikoja, ei käyttöliittymäajuri voi
ainoastaan tuottaa standardinmukaisia lomakkeita, vaan sen täytyy
yrittää tunnistaa asiakasohjelma (selaintyyppi ja versio) ja kiertää
jollakin tavalla siinä tunnetut ongelmat. Viallisten selainten tukeen
kuluva työaika on helpompi perustella, koska ajuri on yhteinen monelle
eri sovellukselle, joten kustannukset ohjelmaa kohden ovat pienempiä
kuin perinteisellä mallilla. Eräissä, erityisesti ulkonäköön liittyvissä
yksityiskohdissa, samaan lopputulokseen on mahdollista pyrkiä usealla
eri tavalla standardin puitteissa ja näistä täytyy kokeilemalla etsiä
se malli, joka toimii eri selaimissa. Tällöin eri selaimia varten ei
tarvitse kirjoittaa selainkohtaisia ominaisuuksia.

Koska käyttöliittymäajurin täytyy huolehtia kaikista selaimen käytöstä
johtuvista ongelmista, on sen toteuttaminen vaikeaa. HTML"-kieltä
tukevan ajurin ei kuitenkaan tarvitse ottaa kantaa käyttöliittymän
yksityiskohtiin, ainoastaan eri komponenttien järjestykseen, sillä
ulkonäölliset yksityiskohdat, kuten värit ja elementtien asemoinnit
voidaan käsitellä vasta selaimessa käyttäjän tietokoneella CSS"-kielen
avulla \cite{w3:css}. Sovellukselle voidaan helposti tuottaa erilaisia
ulkoasuja (\alt{skins}) pelkästään luomalla erilaisia CSS"-tiedostoja.
Lisäksi standardi mahdollistaa eri CSS"-tiedostojen kirjoittamisen
esimerkiksi normaalille selaimelle, dataprojektorille ja
kämmentietokoneille; käyttöliittymän ulkoasu on siis mahdollista hioa
tarvittaessa laitekohtaisesti.

\section{Nelikerroksisen mallin käytännön ongelmia}

Aloin toteuttamaan käyttöliittymäajuriajatusta Peda.net"-hankkeessa
tehtävän Oppimappi"-nimisen työkalun
valmistuksessa\footnote{Oppimappi"-työkalusta kerrotaan tarkemmin
luvussa \ref{pedanet-oppimappi}}. Peda.net"-hankkeessa on päätetty
yhdenmukaistaa sovellusten toimintaympäristöksi Apache"-www"-palvelimen
päällä toimiva PHP"-ohjelmointiympäristö sekä MySQL"-tietokanta, joten
tämä asetti käytännön rajoituksia ohjelman loogiseen rakenteeseen;
nykyisin käytössä oleva PHP"-kielen versio 4 ei tue moniperintää eikä
rajapintaluokkia, joten luokkahierarkian toteuttaminen vaati osin
teoriittisesta mallista poikkeamista.

% Oppimappia voi käyttää sekä MySQL
% että PostgreSQL "=tietokantojen päällä. Nykyisellä palvelimella MySQL
% toimii nopeammin.

Kuvassa \ref{fig:oppimappi-schema-orig} on esitetty osa alkuperäisestä
luokkahierarkiasta.

%Kuvassa \ref{fig:oppimappi-big-picture} on puolestaan
%mallinnettu ympäristöä isommassa mittakaavassa. Käytännössä
%MySQL"-tietokanta ja Oppimappi PHP"-sovellus toimivat
%Peda.net"-hankkeen ylläpitämällä palvelimella ja ohjelman
%käyttöliittymä esitetään HTML ja CSS "=kielien avulla sovelluksen
%käyttäjän koneessa toimivassa www"-selaimessa.

\begin{kuva}
\includegraphics[width=\linewidth]{kuvat/oppimappi-schema-orig}
\caption{Alkuperäistä suunnitelmaa Oppimapin toteuttamiseksi}
\label{fig:oppimappi-schema-orig}
\end{kuva}

Noin kuukauden kehitystyön jälkeen kävi kuitenkin selväksi, että
PHP"-ympäristön suorituskyky olioiden luomisessa ja tuhoamisessa oli
aika heikko. Lisäksi täydellisen käyttöliittymäajurin tekeminen alkoi
varmistumaan liian työlääksi siitä saataviin etuihin verrattuna.

\section{Käyttöliittymäajurin yksinkertaistaminen}

Päädyin siihen johtopäätökseen, ettei täydellistä käyttöliittymäajuria
kannata tehdä, koska varsinaisen sovelluslogiikan ja käyttäjän
välissä on niin useita tasoja. Jakamalla käyttöliittymä sopivasti HTML
ja CSS -kielien vastuulle, käyttöliittymäajuri voidaan pitää hyvin
yksinkertaisena. Tätä on havainnollistettu kuvassa
\ref{fig:oppimappi-big-picture}. Lisäksi, koska PHP rajaa ainakin
toistaiseksi natiivin käyttöliittymän kehittämisen mahdollisuuksia
suoritusympäristönsä vuoksi, ei natiivisovelluksen kehittämisen
helpottamiseksi kannattanut tässä vaiheessa uhrata aikaa.

\begin{kuva}
\includegraphics[width=4.2cm]{kuvat/oppimappi-big-picture}
\caption{Oppimapin rakenne kerroksina}
\label{fig:oppimappi-big-picture}
\end{kuva}


Kuvassa \ref{fig:oppimappi-schema-current} on  esitetty Oppimapissa
loppujen lopuksi käytetty ratkaisumalli. Tässäkin luokkahierarkia on
hieman erikoinen, mutta ratkaisun taustalla kummittelee vaillinainen
oliotuki PHP"-kielessä. Tätä kirjoittaessa PHP"-kielen versio 5 on jo
ilmestynyt ja siinä osa puutteista onkin korjattu, mutta sen
tuotantokäyttöä kannattanee harkita aikaisintaan ensi vuonna.

\begin{kuva}
\includegraphics[width=\linewidth]{kuvat/oppimappi-schema-current}
\caption{Osa toteutetusta Oppimapin rakenteesta}
\label{fig:oppimappi-schema-current}
\end{kuva}

Käytännössä käyttöliittymästä vastaavan kerroksen pilkkominen osiin
selaimen sekä palvelimen vastuulle aiheutti sen, että
käyttöliittymäajurin piti ymmärtää enemmän selaimen toiminnasta.  Tämän
seurauksena arvioin, että helpoin ratkaisumalli olisi kehittää
sovelluskehys Oppimapin kehittämiseksi. Tulevaisuudessa, kun Oppimapin
lisäksi tehdään uusia työkaluja, voidaan sovelluskehys käyttää
uudelleen. Myös lokalisointiin tarvittava logiikka on yhteinen eri
sovellusten välillä. Itse Oppimappi on vain eri tiedostotyyppejä
toteuttavien moduulien ohjelmakoodi itse sovelluskehyksen rinnalla.
Tällä hetkellä vaikuttaa lisäksi siltä, että suurin osa Peda.netin
tulevista sovelluksista voidaan kirjoittaa Oppimapin moduuleiksi sen
sijaan, että niistä tehtäisiin omia, samaa sovelluskehystä käyttäviä
sovelluksia. Oppimapista voidaan myös tarvittaessa rakentaa muita
toimintaympäristöjä jättämällä osa käytössä olevista moduuleista pois
tai korvaamalla niitä uusilla.

\subsection{Tiedon siirto lomakkeiden välillä}

Kaikki Oppimapin moduulit peritään luokasta \class{Document} (ks. kuva
\ref{fig:oppimappi-schema-current}) ja kaikki moduulit saavat oman
nimiavaruuden käyttämilleen parametreille. Tämä on olennaista, koska
istuntoon liittyvää tietoa täytyy kuljettaa kaikkien linkkien
osoitteissa, kuten luvussa \ref{kaikki-data-sivulla} selitin. Eri
moduulien parametrit sijoitetaan puolestaan omiin nimiavaruuksiinsa,
jotta useita moduuleita olisi mahdollista esittää rinnakkain samalla
sivulla. Automaattinen parametrien uudelleennimeäminen mahdollistaa
myös sen, ettei yksittäistä moduulia ohjelmoitaessa tarvitse
tarkistaa mitä nimiä muut moduulit käyttävät.

Esimerkiksi jos moduuli, jonka id"-numero on \code{251} asettaa sivulle
parametrin, jonka nimi on \code{foo}, käytetään todellisena parametrin
nimenä merkkijonoa \code{p251xfoo}. Nimen muunnos tapahtuu
automaattisesti luokan \class{DocumentUI} toimesta.  Lisäksi
\class{DocumentUI}"-luokka ylläpitää automaattisesti istuntotietoa.
Tämä toteutetaan globaalin \code{session}"-parametrin avulla, joka
sisältää käyttäjän ja tietokannan tunnistetiedot sekä varmenteen
tietojen muuttumattomuudesta. Kaikkiin toimintoihin lisätään myös
kullakin hetkellä käytössä olevan moduulin tunniste sekä edellisen
käytössä olleen moduulin tunniste. Näiden tietojen avulla moduulin
kaikista toiminnoista palataan oletuksena takaisin samaan moduuliin,
mutta esimerkiksi \emph{tallenna}"-toiminnon jälkeen voidaan palata
edelliseen moduuliin. Tämän voi ajatella vastaavan tavallisessa
käyttöjärjestelmässä ikkunan sulkemista, jonka jälkeen aktiiviseksi
vaihtuisi edellinen ikkuna.

Oppimappi erottelee istuntoon liittyvän tiedon kahteen eri ryhmään:
ikkunakohtaiset tiedot ja yleiset asetukset. Kaikki yleiset asetukset
tallennetaan palvelimen tietokantaan ja ne haetaan tietokannasta
jokaisen sivun generoinnin alussa. Tietojen hakeminen aina jokaisen
sivun alussa lisää palvelimen kuormaa hieman, mutta se mahdollistaa
kuorman jakamisen eri edustakoneiden kesken, sillä Oppimappia ajava
edustakone ei tallenna mitään tietoja käyttäjästä. Asetukset ja tiedot,
jotka ovat aikaan sidottuja ja joiden vaikutuksen pitää näkyä selaimen
historia"-toimintoja käytettäessä tallennetaan jokaiseen sivuun
upotettuna. Tällä hetkellä ne koodataan kaikkiin linkkeihin, mutta
tulevaisuudessa ne olisi mahdollista sijoittaa sivun sijainnin
osoittavaan polkuun. Koska HTML"-standardi määrittelee suhteellisen viittauksen mahdollisuuden linkeissä, voisi Oppimappi sijoittaa kaikki sivukohtaiset tiedot sivun osoitteeseen.

Esimerkiksi osoitteessa
\code{http://peda.net/mappi""?session=databasetest/""1/""9325""35/""53""252""\&=4""/6""/1}
oleva Oppimapin dokumentti voitaisiin siirtää osoitteeseen 
\code{http://""peda.""net/""mappi/""databasetest.""1.""932535.""53252/""4.""6.""1},
jolloin uuteen sivuun viitatessa ei tarvisisi toistaa enää istuntoon
liittyvää tietoa vaan ainoastaan sivukohtaiset muutokset. Tällöin
esimerkiksi linkki \verb!<a href="?x=y">linkkiteksti</a>! osoittaisi
automaattisesti samaan istuntoon ja samaan dokumenttiin ja selain
lähettäisi linkin mukana parametrin $x$ arvolla ``y''. Nykyisin
kaikissa linkeissä pitää aina toistaa parametrit \code{session} ja
\code{d}.

Koska kaikki nämä tiedot viedään jokaiseen sivuun upotettuna, toimii
edelliseen näkymään palaaminen myös historian kautta avatuissa sivuissa
oikein. Myöskään ikkunan kahdentaminen ei aiheuta ongelmia.
Kirjanmerkkien käyttö toimii lukuunottamatta sitä, että tietoturvan
lisäämiseksi annetut linkit vanhenevat tunnin kuluessa -- kirjanmerkkiä
voidaan käyttää tämänkin jälkeen, mutta sitä käytettäessä
käyttäjätunnus ja salasana kysytään ensin uudelleen.
