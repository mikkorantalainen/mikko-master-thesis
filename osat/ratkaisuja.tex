\chapter{Ratkaisuja selainkäyttöliittymän toteutukseen}

\begin{chapterquote}{Keskustelu Matrix"-elokuvassa}
Neo: "You mean I can dodge bullets?"\\
Morpheus: "I mean when you are ready, you won't have to."
\end{chapterquote}

Luvussa \ref{ongelmia} kuvattiin selainkäyttöisten ohjelmien
käyttöliittymien toteuttamisessa kohdattuja ongelmia. Kuvailen tässä
luvussa ratkaisuvaihtoehtoja kuvattujen ongelmien ratkaisemiseksi. Osa
suunnittelemistani ratkaisuvaihtoehdoista osoittautui
epäkäytännöllisiksi, mutta kuvailen ne siitä huolimatta antamaan kuvaa
ratkaisujen kehityskaaresta.

\section{Käyttöliittymäkerroksen jakaminen osiin}

Ensimmäisenä ajatuksena oli jakaa luvussa \ref{tiers} kuvattu
kolmikerroksinen malli vielä kerran, päätyen nelikerroksiseen
rakenteeseen. Tässä mallissa käyttöliittymäkerros jaetaan
käyttöliittymän toiminnallisuuden kuvaamiseen ja käyttöliittymäajuriin
(kuva \ref{fig:4tier}).

\begin{figure}[htb]
\begin{center}
\includegraphics[width=11cm]{kuvat/fig4tier}
\caption{Kaavio nelikerroksisesta arkkitehtuurista usean sovelluksen
tapauksessa}
\label{fig:4tier}

\end{center}
\end{figure}

Jaon etuna eri sovellusten käyttöliittymät saadaan toimimaan
vastaavalla ulkonäöllä ja mahdollisimman pitkälti vastaavilla
toiminnoilla. Tämä onnistuu jakamalla käyttöliittymäajuri eri
sovellusten kesken. Suunnittelemalla käyttöliittymän toiminnallisuuden
ja käyttöliittymäajurin rajapinta sopivasti, helpottuu käyttöliittymän
kirjoittaminen verrattuna entiseen malliin, jossa käyttöliittymää
kirjoitettaessa jouduttiin kirjoittamaan koodi myös käyttöliittymän eri
osien, kuten erilaisten painikkeiden, hallintaan. Uudessa mallissa
käyttöliittymän kuvauksessa vain ilmoitetaan, että käyttäjän tulee
valita annetusta listasta kaksi tai kolme kohtaa. Käyttöliittymäajuri
voisi sitten toteuttaa tuon esityksen esimerkiksi ryhmällä \alt{radio
button} "=tyyppisiä grafiikkaelementtejä tai vaihtoehtoisesti
valintalaatikon (\alt{select box}) avulla. WWW"-käytössä
käyttöliittymäajurin muodostamaa lopputulosta voitaisiin vielä hioa
kirjoittamalla lomakekohtaisia ulkonäköasetuksia CSS"-kielellä
\cite{w3:css}.

Käyttöliittymäajuri keskustelee www"-selaimen kanssa, mutta
vaihtoehtoisesti sen voisi toteuttaa natiivilla sovelluksella. Tällöin
edes ohjelman käyttöliittymän kuvausta ei tarvitsisi muuttaa vaikka
käyttöympäristö vaihtuisi selainkäyttöisestä natiiviksi. Koska
toiminnallisuuden täytyy kuitenkin olla lomakepohjainen toimiakseen
\emph{hyvin} selaimen kautta, ei tällainen natiivikäyttöliittymä olisi
merkittävästi parempi kuin selainpohjainen käyttöliittymäkään.
Väitänkin, että selainkäyttöisten ohjelmien käyttöliittymien logiikka
ja dialogien rakenne pitääkin suunnitella eri tavalla kuin
perinteisten, käyttöjärjestelmän omien sääntöjen mukaan toimivien
sovellusten.

\subsection{Tiedon käsittelyn logiikka}

Tämä kerros (kuva \ref{fig:4tier}) toteutetaan usein käyttämällä jotain
olemassaolevaa relaatiotietokantaa, esimerkiksi MySQL tai PostgreSQL.
Teoriassa tietokannan pitäisi ymmärtää ja valvoa kaikki tiedon
esitysmalliin liittyvät rajoitukset, jos tämä kerros halutaan toteuttaa
täysin tietokannalla. Käytännössä tähän ei päästä, koska rajanpinta
tiedon käsittelyn logiikan ja sovelluslogiikan välillä on toteutettu
SQL"-kielellä. Monien tietokantojen tuki SQL"-kielelle on varsin
kehittymätön erityisesti tietorakenteen rajoitusten suhteen. Tämän
seurauksena merkittävä osa tiedon esitysmallin rajoituksista joudutaan
sijoittamaan sovelluslogiikkaan. Muuten sovellusta ei voida
tulevaisuudessa siirtää toimimaan toisen tietokannan päällä. Jos
siirrettävyys ei ole tavoitteena, tietokannan tehokkuus voidaan
maksimoida ohjelmoimalla tarkistukset ja rajoitukset tietokannan omilla
työkaluilla.

Pyrin itse pitämään selainkäyttöiset sovellukset
tietokantariippumattomina -- eli käytännössä sijoitan rajoitukset
sovelluslogiikkaan -- koska olen kokenut, että käytännössä eri
tietokannan käyttämisestä saatava nopeusero on suurempi kuin
yksittäisen tietokannan hienosäätämisestä saatava nopeusero. Toisin
sanoen, suurin nopeuden kasvattaminen saataisiin aikaiseksi vaihtamalla
tietokantaa aina sen hetkisen sisällön ja käyttöprofiilin mukaisesti
nopeiten toimivaan. Oliotietokanta voisi helpottaa sovelluksen
kehittämistä, mutta tekniikan kypsyys herättää epäilyksiä. Tämän
tutkielman kannalta tarkka jako tiedon käsittelyn logiikan ja
sovelluslogiikan välillä ei ole kuitenkaan olennaista.

\subsection{Sovelluslogiikka}

Sovelluslogiikka vastaa sovelluksen ``älystä''. Teoriassa tässä
kerroksessa ei oteta mitään kantaa sovelluksen käyttöliittymään.
Käytännössä tämä kerros on todennäköisesti tehokkainta sulauttaa
osittain käyttöliittymän toiminnallisuuden kanssa. Näin sen vuoksi,
että sovelluslogiikkaan ei yleensä ohjelmoida ominaisuuksia, joita
käyttöliittymän toiminnallisuus ei tarvitse. Toisaalta käyttöliittymään
ei voida lisätä ominaisuuksia, joita sovelluslogiikka ei tue. Eli
kaikki muutokset täytyy kuitenkin tehdä molempiin osiin, jonka vuoksi
jaosta ei saada kovin paljon etua. Lisäksi sulauttamisen haittojen voi
neljän kerroksen mallissa olettaa olevan kohtuullisen pieniä, koska
käyttöliittymän toiminnallisuus ei ole enää tiukasti sidottu itse
käyttöliittymän ulkonäköön. Tulevaisuudessa, jos selaimilla voidaan
esittää monimutkaisempia käyttöliittymiä, kannattaa tämä kerros
edelleen pitää erillisenä käyttöliittymän toiminnallisuudesta.

\subsection{Käyttöliittymän toiminnallisuus}

Käyttöliittymän toiminnallisuudesta vastaava kerros kuvaa
käyttöliittymän toiminnan abstraktilla tavalla: ``tästä taulukosta
täytyy valita 2--5 riviä'' tai ``käyttäjän tulee syöttää lomakkeelle
kaksi merkkijonoa. Näiden merkkijonojen nimet ja tyypit ovat
`käyttäjätunnus':merkkijono ja `salasana':salattu merkkijono.'' Tämä
kerros ei ota kantaa siihen missä järjestyksessä taulukon sarakkeet ja
rivit näytetään tai siihen, syötetäänkö käyttäjätunnus tekstikenttään
vai vaikkapa napauttelemalla hiirellä jonkin kuvan eri kohtia.

Teoriassa tämä kerros voisi generoida yksinkertaisen XML"-sivun, joka
muutettaisiin XHTML tai HTML "=sivuksi selaimen toimintoja varten.
Tällöin käyttöliittymäajurin voisi kirjoittaa esimerkiksi
XSLT"-kielellä. Käytännössä tällaisen ajurin kirjoittaminen muodostuu
oletettavasti niin hankalaksi, että paremmalta vaihtoehdolta tuntuu
kirjoittaa käyttöliittymäajuri kirjastoksi, joka
linkitetään\footnote{Joissakin ohjelmointiympäristöissä ohjelmakoodi
käännetään objektitiedostoiksi, jotka yhdistetään \emph{linkittämällä}
valmiin ohjelman tuottamiseksi. Vasta näin tuotettu valmis ohjelma
voidaan suorittaa. Toisaalta, esimerkiksi tulkattavia kieliä
käyttävissä ohjelmissa manuaalinen linkitys ei ole tarpeen, sillä se
suoritetaan automaattisesti ohjelman käynnistyessä kun kirjastoa on
muutettu.} ohjelmaan sitä tehtäessä. Linkitys pitää tehdä käännetyssä
ohjelmassa uudelleen kirjaston päivityksen yhteydessä, mutta itse
käyttöliittymän toiminnallisuuteen ei tarvitse puuttua. Tässäkin
mallissa eri sovellusten käyttöliittymät saadaan säilymään
yhdenmukaisina pelkästään linkittämällä kaikki sovellukset uudelleen
aina käyttöliittymäajurin päivityksen jälkeen.
\cite{w3:xml_v1_0,w3:xhtml,w3:xslt}

\subsection{Käyttöliittymäajuri}

Tämä kerros vastaa siitä kuinka käyttäjä pystyy tekemään eri valinnat
ja toiminnot. Jos käyttöliittymässä on kuvattu, että lomakkeella on 10
vaihtoehtoa, joista pitää valita täsmälleen yksi voi selainkäyttöisen
sovelluksen käyttöliittymäajuri näyttää sivulla 10 linkkiä, joista
käyttäjä painaa yhtä. \emph{Vaihtoehtoisesti} ajuri voisi näyttää
lomakkeen jossa on 10 \alt{radio button} "=tyyppistä elementtiä ja
OK"-painike. Kolmas vaihtoehto olisi näyttää
\alt{combobox}"-alasvetovalikko yhdistettynä JavaScript"-käsittelijään,
joka lähettäisi lomakkeen välittömästi käyttäjän näpäytettyä jotain
kohtaa. Optimaalisessa tapauksessa käyttöliittymäajuri osaisi käyttää
kaikkia näitä vaihtoehtoja ja käyttäjä voisi omissa asetuksissaan
valita millä tyylillä hän haluaa käyttää erityyppisiä lomakkeita.

\subsection{Käyttöliittymäajurille jää paljon vastuuta}
\label{kaikki-data-sivulla}

Koska selainkäyttöisen sovelluksen käyttäjä voi esimerkiksi haarauttaa
istunnon ja tästä toiminnosta ei synny tapahtumaa palvelimelle, täytyy
kaikki tieto kuljettaa lomakkeen muun tiedon yhteydessä sivuun
upotettuna. Tällöin tieto kopioidaan automaattisesti, kun käyttäjä
haarauttaa istunnon eli käytännössä avaa uuden ikkunan, jossa on sama
sovellus toiminnassa. Samoin historiatoimintojen yhteydessä selain
käyttää automaattisesti entisen lomakkeen tietoja, sillä nuo tiedot
sisältyvät siihen sivuun, jota selain käyttää sivun näyttämiseenkin.
Käyttöliittymäajuri ei voi estää vanhentuneen tiedon saapumista, joten
käyttöliittymän toiminnallisuuden tai sovelluslogiikan täytyy ottaa
siihen kantaa.\footnote{Käyttäjä voisi esimerkiksi muokata
selainkäyttöliittymällä uutisartikkelia, poistaa artikkelin ja käyttää
\emph{takaisin} toimintoa palatakseen takaisin muokkaus"-toimintoon.
Kun käyttäjä nyt tallentaa tehdyt muokkaukset täytyy sovelluksen joko
palauttaa poistettu artikkeli tai luoda lähetettyjen tietojen
perusteella uusi. Muuten käyttäjän lähettämää tietoa hukkuu.}

Istunnon ylläpitoon tarvittavan tiedon määrän täytyy olla pieni, koska
kaikkien sovelluksen generoimien sivujen sisältämien linkkien täytyy
sisältää myös istunnon tiedot.\footnote{WWW"-sivulla olevat linkit
käyttävät aina GET"-metodia HTTP"-yhteyksiä käytettäessä, jossa kaikki
linkin parametrit pitää siirtää tekstinä osoitteen lopussa. Istuntoon
liittyvät tiedot täytyy siis toistaa sivun \emph{jokaisen} linkin
lopussa ja sivu kasvaa huomattavan nopeasti linkkien lukumäärän mukaan
jos istunto"-tietoa on paljon.} HTTP"-protokolla määrittelee
tavallisten linkkien käyttämän GET"-toiminnon maksimidatamääräksi neljä
kilotavua, joka asettaa ylärajan istunnon koolle.
\cite{ietf:http}

Koska \emph{kaikkien} sovellusten tietojen lähettäminen jokaisen
lomakkeen yhteydessä vaatisi huomattavan lisän tarvittavaan
tiedonsiirtokaistaan, tulee ohjelman toteutuksessa erikseen jakaa
istunto"-tiedot kahteen osaan: lomakkeiden kautta siirtyvä tieto, ja
tieto, joka voidaan jakaa myös haarautettujen tai vanhentuneiden
tapahtumien kanssa. Tällöin jaettu tieto voidaan säilyttää
palvelimella. Tällaista jaettua tietoa olisivat muun muassa käyttäjän
henkilökohtaiset asetukset, jotka voidaan jakaa eri ikkunoiden kesken.
Esimerkiksi valittu koko sivuston tyyli tai päivämäärien esitysmuoto
olisi tällaista tietoa. Jakamatonta istuntotietoa olisi taas
esimerkiksi tieto siitä, mitä toimintoja käyttäjä käytti saapuessaan
nykyiseen näkymään, jos tätä tietoa tarvitaan tulevaisuudessa.

Tulevaisuudessa selainkäyttöisen sovelluksen käyttöliittymäajuri voisi
esittää käyttöliittymän XForms"-määrityksen mukaisilla lomakkeilla,
jolloin käyttöliittymän toiminnallisuus ja ulkonäkö voidaan pitää
erillään www"-selaimeen asti. Ikävä kyllä XForms on hyvin heikosti
tuettu uusimmissakin selaimissa eikä mikään viittaa siihen, että
tilanteeseen olisi tulossa nopeasti muutosta.
\cite{korpela:html_forms,w3:xforms}

\subsection{Huomioita käyttöliittymäajurin toteuttamiseen liittyen}

Koska eri selaimissa on erilaisia vikoja, ei käyttöliittymäajuri voi
ainoastaan tuottaa standardinmukaisia lomakkeita, vaan sen täytyy
yrittää tunnistaa asiakasohjelma (selaintyyppi ja versio) ja kiertää
jollakin tavalla siinä tunnetut ongelmat. Viallisten selainten tukeen
kuluva työaika on helpompi perustella, koska ajuri on yhteinen monelle
eri sovellukselle, joten kustannukset ohjelmaa kohden ovat pienempiä
kuin perinteisellä mallilla. 

Esimerkiksi Microsoft Internet Explorerissa takaisin"-painike ei toimi
POST"-metodin käyttämisen jälkeen, jos lomakkeen \emph{Cache-Control}
otsake sisältää tunnisteen \code{no-cache}. Tämä tunniste kieltää
standardin mukaan sivun tallentamisen levylle, mutta ei estä
esimerkiksi sivun säilyttämistä päätelaitteen muistissa. Koska
Microsoft saattaa korjata tämän vian tulevaisuudessa ei ole kuitenkaan
järkevää poistaa \code{no-cache}"-tunnistetta sovelluksesta yleisesti
vaan ainoastaan poistaa se Internet Explorer 6.0 ja sitä vanhemmille
versioille tarjottavista sivuista. Vastaavia ongelmia löytyy muista
selaimista. Selainkohtaiset korjaukset on tärkeää tehdä siten, että
tuntemattomalle selaimen versiolle tarjotaan aina standardin mukainen
sivu. Tällöin tulevaisuudessa standardia tukeva selain saa aina oikein
toimivan näkymän.

Eräissä, erityisesti ulkonäköön liittyvissä yksityiskohdissa, samaan
lopputulokseen on mahdollista pyrkiä usealla eri tavalla standardin
puitteissa ja näistä täytyy kokeilemalla etsiä se malli, joka toimii
eri selaimissa. Tällöin eri selaimia varten ei tarvitse kirjoittaa
selainkohtaisia ominaisuuksia. Joitakin ongelmia ei voi kuitenkaan
kiertää standardin puitteissa.

Koska käyttöliittymäajurin täytyy huolehtia kaikista selaimen käytöstä
johtuvista ongelmista, on sen toteuttaminen vaikeaa. HTML"-kieltä
tukevan ajurin ei kuitenkaan tarvitse ottaa kantaa käyttöliittymän
yksityiskohtiin, ainoastaan eri komponenttien järjestykseen.
Ulkonäölliset yksityiskohdat, kuten värit ja elementtien asemoinnit
voidaan käsitellä vasta selaimessa käyttäjän tietokoneella CSS"-kielen
avulla \cite{w3:css}. Sovellukselle voidaan helposti tuottaa erilaisia
ulkoasuja (\alt{skins}) pelkästään luomalla erilaisia CSS"-tiedostoja.
Lisäksi standardi mahdollistaa eri CSS"-tiedostojen kirjoittamisen
esimerkiksi tavallisille selaimille, dataprojektoreille, ääniselaimille
ja kämmentietokoneille; käyttöliittymän esitystä on siis mahdollista
hioa tarvittaessa ympäristökohtaisesti.

\section{Nelikerroksisen mallin käytännön ongelmia}

Aloin toteuttamaan käyttöliittymäajuriajatusta Peda.net"-hankkeessa
tehtävän Oppimappi"-nimisen työkalun valmistuksessa, kerrotaan
tarkemmin luvussa \ref{pedanet-oppimappi}. Peda.net"-hankkeessa on
päätetty yhdenmukaistaa sovellusten toimintaympäristöksi Apache
www"-palvelimen päällä toimiva PHP"-ohjelmointiympäristö sekä
MySQL"-tietokanta, joten tämä asetti käytännön rajoituksia ohjelman
loogiseen rakenteeseen; nykyisin käytössä oleva PHP"-kielen versio 4 ei
tue moniperintää eikä rajapintaluokkia, joten luokkahierarkian
toteuttaminen vaati osin kirjallisuudessa esitetyistä malleista
poikkeamista.

Kuvassa \ref{fig:oppimappi-schema-orig} on esitetty osa alkuperäisestä
luokkahierarkiasta. Siinä sovellus muodostui Oppimapista ja sen avulla
käytettävistä moduuleista, jotka toteuttivat käyttöliittymän
käyttöliittymäajurin luokkien avulla. Yksittäiset dokumenttityypit,
kuten \code{SimpleText} ja \code{Folder} perittiin
\code{Document}"-luokasta, joka auttoi istuntokohtaisen tiedon
hallinnassa sekä tietokannan käsittelyssä. Yksittäisen dokumentin koodi
käynnistettiin vaiheessa, jossa käyttäjän istunnon voimassaolo oli
varmistettu ja dokumentin tiedot oli haettu tietokannasta. Tämän
jälkeen dokumentti siirtyi suoritusvaiheeseen, jossa se teki kaikki
päivitykset tietokannan sisältöön. Tämän vaiheen jälkeen dokumentti
siirtyi käyttöliittymän luontivaiheeseen, jolloin moduuli koosti
käyttöliittymän käyttöliittymäajurin tarjoamien luokkien avulla. Luokat
käynnistettiin vielä erillisen \code{UIFactory}"-luokan kautta
tulevaisuuden muutosten helpottamiseksi. Suoritusvaihe ja
käyttöliittymän luonti on jaettu kahteen vaiheeseen, jotta
tulevaisuudessa useita dokumenttityyppejä voidaan tarvittaessa ajaa
samalla sivulla rinnakkain. Tällöin jokainen dokumentti voi vaikuttaa
yleisiin asetuksiin ja muutos ehtii vaikuttamaan muiden dokumenttien
näyttämässä käyttöliittymässä.

\begin{kuva}
\includegraphics[width=15.4cm]{kuvat/oppimappi-schema-orig}
\caption{Alkuperäistä suunnitelmaa Oppimapin toteuttamiseksi}
\label{fig:oppimappi-schema-orig}
\end{kuva}

Noin kuukauden kehitystyön jälkeen kävi kuitenkin selväksi, että
PHP"-ympäristön suorituskyky olioiden luomisessa ja tuhoamisessa oli
aika heikko. Lisäksi täydellisen käyttöliittymäajurin tekeminen alkoi
varmistua liian työlääksi siitä saataviin etuihin verrattuna.

\section{Käyttöliittymäajurin yksinkertaistaminen}

Päädyin siihen johtopäätökseen, ettei täydellistä käyttöliittymäajuria
kannata tehdä, koska varsinaisen sovelluslogiikan ja käyttäjän välissä
on niin useita tasoja. Jakamalla käyttöliittymäajurin toteutus osittain
HTML ja CSS -kielien vastuulle, voidaan käyttöliittymäajuri pitää
kohtuullisen yksinkertaisena. Tätä on havainnollistettu kuvassa
\ref{fig:oppimappi-big-picture}. Erona entiseen malliin,
käyttöliittymäajurin tehtäviä on siirretty sekä selaimelle HTML ja CSS
-kielien muodossa, että käyttöliittymän toiminnallisuuteen, jossa
käytetään hyväksi tietoa, että lopputuloksen on tarkoitus olla
XML"-muodossa. Sovellus tulostaa siis XHTML"-kielisen esityksen ja
käyttöliittymäajurin rajapinta tuottaa suoraan XML"-kielisiä palasia
(\alt{XML Fragment}). Koska PHP"-kieli rajaa ainakin toistaiseksi
natiivin käyttöliittymän kehittämisen mahdollisuuksia
suoritusympäristönsä vuoksi, ei natiivisovelluksen kehittämisen
helpottamiseksi kannattanut tässä vaiheessa uhrata aikaa.

Erona tavalliseen 3"-kerrosmalliin on, että käyttöliittymäkerros on
jaettu osiin palvelimen ja asiakkaan välille.

\begin{kuva}
\includegraphics[width=4.2cm]{kuvat/oppimappi-big-picture}
\caption{Oppimapin rakenne kerroksina}
\label{fig:oppimappi-big-picture}
\end{kuva}

\begin{kuva}
\includegraphics[width=\linewidth]{kuvat/oppimappi-schema-current}
\caption{Osa toteutetusta Oppimapin rakenteesta}
\label{fig:oppimappi-schema-current}
\end{kuva}

Kuvassa \ref{fig:oppimappi-schema-current} on  esitetty Oppimapissa
loppujen lopuksi käytetty ratkaisumalli. Merkittävänä erona
alkuperäiseen malliin \code{UIFactory}"-luokka on poistettu kokonaan ja
sen korvaa \code{DocumentUI}. Päädyin tähän tulokseen, koska
käytännössä \code{UIFactory}"-luokan metodit tarvitsivat usein
istunto"-tietoa, joka oli saavutettavissa vain
\code{DocumentCore}"-luokan kautta. Istuntotiedon kuljettaminen
kaikkien käyttöliittymäajurin luokkien yhteydessä oli hankalaa. Lisäksi
istunnon kuljettaminen parametrina oli turhaa uudessa mallissa, koska
istunto ei koskaan muutu yksittäisen dokumentin suorituskerran aikana.
Samoin \code{Document}"-luokka jaettiin kolmeen luokkaan.
\code{DocumentCore} sisältää ne metodit, joita tarvitaan kaikkiin
dokumenttityyppeihin, myös sellaisiin, joilla ei ole käyttöliittymää
ollenkaan. \code{DocumentActions} sisältää metodit, joita kaikki
käyttöliittymän sisältävät dokumentit tukevat kuten versionhallinnan
käyttöliittymä. \code{Document}"-luokka sisältää joitakin
erikoistoimintoja, joita Oppimappi käyttää. Samaa runkoa myöhemmin
muissa selainkäyttöisissä sovelluksissa käytettäessä
\code{Document}"-luokka voidaan joutua kirjoittamaan uudelleen.
Varsinainen Oppimappi peritään \code{Application}"-luokasta, joka
sisältää HTML"-koodin generoitiin tarvittavat metodit, sekä huolehtii
sisäänkirjautumisesta.

Tässäkin luokkahierarkia on siis hieman erikoinen, mutta ratkaisun
taustalla kummittelee vaillinainen oliotuki PHP"-kielessä.  Tätä
kirjoittaessa PHP"-kielen versio 5 on jo ilmestynyt ja siinä osa
puutteista onkin korjattu, mutta sen tuotantokäyttöä kannattanee
harkita aikaisintaan ensi vuonna. Jos PHP olisi tukenut moniperintää
tai edes rajapintaluokkia, olisi ohjelman rakenne \code{Document} ja
\code{DocumentUI} -luokkien suhteen ollut erilainen. Nyt ohjelman
koodissa esitetty perintähierarkia ei vastaa kunnolla loogista
rakennetta. Tällä ei ole ollut toistaiseksi merkitystä ja koodi on
pyritty kirjoittamaan siten, että muutos on kohtuullisen helppo tehdä
kun kieli myöhemmin alkaa tukemaan sitä.

Käytännössä käyttöliittymästä vastaavan kerroksen pilkkominen osiin
selaimen sekä palvelimen vastuulle aiheutti sen, että
käyttöliittymäajurin piti ymmärtää enemmän selaimen toiminnasta.  Tämän
seurauksena arvioin, että helpoin ratkaisumalli olisi kehittää
sovelluskehys Oppimapin kehittämiseksi. Tulevaisuudessa, kun Oppimapin
lisäksi tehdään uusia työkaluja, voidaan sovelluskehys käyttää
uudelleen. Myös lokalisointiin tarvittava logiikka on yhteinen eri
sovellusten välillä. Itse Oppimappi on vain eri tiedostotyyppejä
toteuttavien moduulien ohjelmakoodi itse sovelluskehyksen rinnalla.
Tällä hetkellä vaikuttaa lisäksi siltä, että suurin osa Peda.netin
tulevista sovelluksista voidaan kirjoittaa Oppimapin moduuleiksi sen
sijaan, että niistä tehtäisiin omia, samaa sovelluskehystä käyttäviä
sovelluksia. Oppimapista voidaan myös tarvittaessa rakentaa muita
toimintaympäristöjä jättämällä osa käytössä olevista moduuleista pois
tai korvaamalla niitä uusilla.

\subsection{Tiedonsiirto lomakkeiden välillä}

Kaikki Oppimapin moduulit peritään luokasta \class{Document} (ks. kuva
\ref{fig:oppimappi-schema-current}) ja kaikki moduulit saavat oman
nimiavaruuden käyttämilleen parametreille. Tämä on olennaista, koska
istuntoon liittyvää tietoa täytyy kuljettaa kaikkien linkkien
osoitteissa, kuten luvussa \ref{kaikki-data-sivulla} perustelin. Eri
moduulien parametrit sijoitetaan puolestaan omiin nimiavaruuksiinsa,
jotta useita moduuleita olisi mahdollista esittää rinnakkain samalla
sivulla. Automaattinen parametrien uudelleennimeäminen mahdollistaa
myös sen, ettei yksittäistä moduulia ohjelmoitaessa tarvitse tarkistaa
mitä nimiä muut moduulit käyttävät.

Jos esimerkiksi moduuli, jonka id"-numero on \code{251}, asettaa
sivulle parametrin, jonka nimi on \code{foo}, käytetään todellisena
parametrin nimenä merkkijonoa \code{p251xfoo}. Nimen muunnos tapahtuu
automaattisesti luokan \class{DocumentUI} toimesta.  Lisäksi
\class{DocumentUI}"-luokka ylläpitää automaattisesti istuntotietoa.
Tämä toteutetaan globaalin \code{session}"-parametrin avulla, joka
sisältää käyttäjän ja tietokannan tunnistetiedot sekä varmenteen
tietojen muuttumattomuudesta. Sivun kaikkiin toimintolinkkeihin
lisätään myös kullakin hetkellä käytössä olevan moduulin tunniste sekä
edellisen käytössä olleen moduulin tunniste. Näiden tietojen avulla
moduulin kaikista toiminnoista palataan oletuksena takaisin samaan
moduuliin, mutta esimerkiksi \emph{tallenna}"-toiminnon jälkeen voidaan
palata edelliseen moduuliin. Tämän voi ajatella vastaavan tavallisessa
käyttöjärjestelmässä ikkunan sulkemista, jonka jälkeen aktiiviseksi
vaihtuisi edellinen ikkuna.

Oppimappi erottelee istuntoon liittyvän tiedon kahteen eri ryhmään:
näkymäkohtaiset tiedot ja yleiset asetukset. Kaikki yleiset asetukset
tallennetaan palvelimen tietokantaan ja ne haetaan tietokannasta
jokaisen sivun tulostamisen alussa. Tietojen hakeminen aina jokaisen
sivun alussa lisää palvelimen kuormaa. Toisaalta se mahdollistaa
kuorman jakamisen helposti eri edustakoneiden kesken, sillä Oppimappia
ajava edustakone ei tallenna mitään tietoja käyttäjistä. Asetukset ja
tiedot, jotka ovat aikaan sidottuja ja joiden vaikutuksen pitää näkyä
selaimen historia"-toimintoja käytettäessä, tallennetaan jokaiseen
sivuun upotettuna. Tällä hetkellä ne koodataan kaikkiin linkkeihin,
mutta tulevaisuudessa ne olisi mahdollista sijoittaa sivun sijainnin
osoittavaan polkuun. Koska HTML sallii suhteellisten linkkien
käyttämien, voisi Oppimappi upottaa kaikki sivukohtaiset tiedot sivun
osoitteeseen, jolloin ne toistuvat automaattisesti kaikissa
suhteellisissa linkeissä.

Esimerkiksi osoitteessa
\code{http://peda.net/mappi""?session=databasetest/""1/""9325""35/""53""252""\&d=4""/6""/1}
oleva Oppimapin dokumentti voitaisiin siirtää osoitteeseen
\code{http://""peda.""net/""mappi/""databasetest.""1.""932535.""53252/""4.""6.""1}.
Nyt tältä sivulta toiselle Oppimapin sivulle linkitettäessä ei
tarvitsisi toistaa enää istuntoon liittyvää tietoa vaan ainoastaan
sivukohtaiset muutokset. Esimerkiksi HTML"-kielellä kirjoitettu
toimintolinkki
\verb!<a~href="?action=x">!""\verb!linkkiteksti!""\verb!</a>!
osoittaisi automaattisesti samaan istuntoon ja samaan dokumenttiin ja
selain lähettäisi linkin mukana parametrin $action$ arvolla ``x''.
Nykyisin kaikissa linkeissä pitää aina toistaa parametrit
\code{session} ja \code{d}. Ongelmaa ei voi kiertää esimerkiksi keksien
(\alt{cookies}) avulla, koska ne eivät toimi yhteistyössä selaimen
historia"-toimintojen kanssa. Samoin usealla eri käyttäjällä
kirjautuminen selaimen eri ikkunoissa ei toimisi. Todellisuudessa
Oppimappi siirtää kaikissa toiminnoissa lisäksi historiatietoa
edellisistä näkymistä, jolloin esimerkiksi ``Tallenna''"-toiminnon
jälkeen on mahdollista palata käyttäjän mielestä oikeaan näkymään.

Ongelmana tässä tekniikassa on, että käyttäjä ei voi kopioida
osoitepalkista osoitetta sellaisenaan kaverilleen. Tietoturvan vuoksi
osoitteeseen on upotettu tarkistussumma, johon vaikuttaa kävijän
IP"-numero. Jos linkki lähetetään esimerkiksi sähköpostissa toiselle
käyttäjälle, kysytään käyttäjätunnus ja salasana uudelleen IP"-numeron
muuttumisen jälkeen. Oppimapissa käyttäjän luomissa linkeissä ei
käytetä URL"-osoitteita vaan symbolisia viittauksia. Tällä hetkellä on
vielä ratkaisematon ongelma, kuinka sähköpostissa voidaan kuljettaa
linkki siten, että käyttäjän ei tarvitse kirjautua sitä käyttäessään ja
samaan aikaa voidaan tukea sitä, että käyttäjällä on useita eri
käyttäjätunnuksia sisäänkirjattuna; mitä käyttäjätunnusta tällaisen
linkin pitäisi käyttää? Selkein ratkaisu olisi käyttää
käyttäjätunnusta, jolla viimeisin sisäänkirjautuminen on tehty ja
siirtää tämä tieto eri ikkunoiden välillä keksien avulla.
Vaihtoehtoisesti käyttäjälle voitaisiin näyttää sivu, jossa häntä
pyydetään valitsemaan jokin sisäänkirjatuista käyttäjätunnuksista
linkin seuraamiseksi. Mitään yksinkertaista ratkaisua ongelmaan ei ole,
koska HTML ja HTTP rajoittavat mahdollisuuksia. Lisäongelmia
aiheuttavat vialliset selaimet.

Koska kaikki nämä tiedot viedään jokaiseen sivuun upotettuna, toimii
edelliseen näkymään palaaminen myös historian kautta avatuissa sivuissa
oikein. Myöskään ikkunan kahdentaminen ei aiheuta ongelmia.
Kirjanmerkkien käyttö toimii lukuunottamatta sitä, että tietoturvan
lisäämiseksi annetut linkit vanhenevat tunnin kuluessa -- kirjanmerkkiä
voidaan käyttää tämänkin jälkeen, mutta sitä käytettäessä
käyttäjätunnus ja salasana kysytään ensin uudelleen.
