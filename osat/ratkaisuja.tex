\chapter{Ratkaisuja selainkäyttöliittymän toteutukseen}

\begin{chapterquote}{Keskustelu Matrix"-elokuvassa}
Neo: "You mean I can dodge bullets?"\\
Morpheus: "I mean when you are ready, you won't have to."
\end{chapterquote}

Kuten luvussa \ref{ongelmia} kuvasin, selainkäyttöisten ohjelmien
käyttöliittymien toteuttamisessa on useita ongelmia. Kuvailen tässä
luvussa ratkaisuvaihtoehtoja tuossa luvussa kuvattujen ongelmien
ratkaisemiseksi. Osa suunnittelemistani ratkaisuvaihtoehdoista
osoittautui epäkäytännöllisiksi, mutta kuvailen ne siitä huolimatta
antamaan kuvaa ratkaisujen kehityskaaresta.

\section{Käyttöliittymäkerroksen jakaminen osiin}

Ensimmäisenä ajatuksena oli jakaa luvussa \ref{tiers} kuvattu
kolmikerroksinen malli vielä kerran, päätyen nelikerroksiseen
rakenteeseen. Tässä mallissa käyttöliittymäkerros jaetaan
käyttöliittymän toiminnallisuuden kuvaamiseen ja käyttöliittymäajuriin
(kuva \ref{fig:4tier}).

\begin{figure}[htb]
\begin{center}
\includegraphics[width=10cm]{kuvat/fig4tier}
\caption{Kaavio nelikerroksista arkkitehtuurista usean sovelluksen
tapauksessa}
\label{fig:4tier}

\end{center}
\end{figure}

Jaon etuna eri sovellusten käyttöliittymät saadaan toimimaan
vastaavalla ulkonäöllä ja mahdollisimman pitkälti vastaavilla
toiminnoilla. Tämä onnistuu jakamalla käyttöliittymäajuri eri
sovellusten kesken. Suunnittelemalla käyttöliittymän toiminnallisuuden
ja käyttöliittymäajurin rajapinta sopivasti, helpottuu käyttöliittymän
kirjoittaminen verrattuna entiseen malliin, jossa käyttöliittymää
kirjoitettaessa jouduttiin kirjoittamaan koodi myös käyttöliittymän eri
osien, kuten erilaisten painikkeiden, hallintaan. Uudessa mallissa
käyttöliittymän kuvauksessa vain ilmoitetaan, että käyttäjän tulee
valita annetusta listasta kaksi tai kolme kohtaa. Käyttöliittymäajuri
voisi sitten toteuttaa tuon esityksen esimerkiksi ryhmällä \alt{radio
button} "=tyyppisiä grafiikkaelementtejä tai vaihtoehtoisesti
valintalaatikon (\alt{select box}) avulla. WWW"-käytössä
käyttöliittymäajurin muodostamaa lopputulosta voitaisiin vielä hioa
kirjoittamalla lomakekohtaisia ulkonäköasetuksia CSS"-kielellä
\cite{w3:css}.

Käyttöliittymäajuri keskustelee www"-selaimen kanssa, mutta
vaihtoehtoisesti sen voisi toteuttaa natiivilla sovelluksella. Tällöin
edes ohjelman käyttöliittymän kuvausta ei tarvitsisi muuttaa vaikka
käyttöympäristö vaihtuisi selainkäyttöisestä natiiviksi. Koska
toiminnallisuuden täytyy kuitenkin olla lomakepohjainen toimiakseen
\emph{hyvin} selaimen kautta, ei tällainen natiivikäyttöliittymä olisi
merkittävästi parempi kuin selainpohjainen käyttöliittymäkään.
Väitänkin, että selainkäyttöisten ohjelmien käyttöliittymien logiikka
ja dialogien rakenne pitääkin suunnitella eri tavalla kuin
perinteisten, käyttöjärjestelmän omien sääntöjen mukaan toimivien
sovellusten.

\subsection{Tiedon käsittelyn logiikka}

Tämä kerros toteutetaan käyttämällä jotain olemassaolevaa tietokantaa,
esimerkiksi MySQL tai PostgreSQL. Teoriassa tietokannan pitäisi
ymmärtää ja valvoa kaikki tiedon esitysmalliin liittyvät rajoitukset.
Käytännössä tähän ei päästä, koska rajanpinta tiedon käsittelyn
logiikan ja sovelluslogiikan välillä on toteutettu SQL"-kielellä. Monien
tietokantojen tuki SQL"-kielelle on varsin kehittymätön erityisesti
tietorakenteen rajoitusten suhteen. Tämän seurauksena merkittävä osa
tiedon esitysmallin rajoituksista joudutaan sijoittamaan
sovelluslogiikkaan. Muuten sovellusta ei voida tulevaisuudessa siirtää
toimimaan toisen tietokannan päällä. Jos siirretävyys ei ole
tavoitteena, tietokannan tehokkuus voidaan maksimoida ohjelmoimalla
tarkistukset ja rajoitukset tietokannan omilla työkaluilla. Pyrin itse
pitämään selainkäyttöiset sovellukset tietokantariippumattomina -- eli
sijoitan rajoitukset sovelluslogiikkaan -- koska olen kokenut, että
käytännössä eri tietokannan käyttämisestä saatava nopeusero on suurempi
kuin yksittäisen tietokannan hienosäätämisestä saatava nopeusero.
Toisin sanoen, suurin nopeuden kasvattaminen saataisiin aikaiseksi
vaihtamalla tietokantaa aina sen hetkisen sisällön ja käyttöprofiilin
mukaisesti nopeiten toimivaan. Tämän tutkielman kannalta tarkka jako
tiedon käsittelyn logiikan ja sovelluslogiikan välillä ei ole
kuitenkaan olennaista.

\subsection{Sovelluslogiikka}

Sovelluslogiikka vastaa sovelluksen ``älystä''. Teoriassa tässä
kerroksessa ei oteta mitään kantaa sovelluksen käyttöliittymään.
Käytännössä tämä kerros on todennäköisesti tehokkainta sulauttaa
osittain käyttöliittymän toiminnallisuuden kanssa. Näin sen vuoksi,
että sovelluslogiikkaan ei yleensä ohjelmoida ominaisuuksia, joita
käyttöliittymän toiminnallisuus ei tarvitse. Toisaalta käyttöliittymään
ei voida lisätä ominaisuuksia, joita sovelluslogiikka ei tue. Eli
kaikki muutokset täytyy kuitenkin tehdä molempiin osiin, jonka vuoksi
jaosta ei saada kovin paljon etua. Lisäksi sulauttamisen haittojen voi
neljän kerroksen mallissa olettaa olevan kohtuullisen pieniä, koska
käyttöliittymän toiminnallisuus ei ole enää tiukasti sidottu itse
käyttöliittymän ulkonäköön.

\subsection{Käyttöliittymän toiminnallisuus}

Käyttöliittymän toiminnallisuudesta vastaava kerros kuvaa
käyttöliittymän toiminnan abstraktilla tavalla: ``tästä taulukosta
täytyy valita 2--5 riviä'' tai ``käyttäjän tulee syöttää lomakkeelle
kaksi merkkijonoa. Näiden merkkijonojen nimet ja tyypit ovat
`käyttäjätunnus':merkkijono ja `salasana':salattu merkkijono.'' Tämä
kerros ei ota kantaa siihen missä järjestyksessä taulukon sarakkeet ja
rivit näytetään tai siihen, syötetäänkö käyttäjätunnus tekstikenttään
vai vaikkapa napauttelemalla hiirellä jonkin kuvan eri kohtia.

Teoriassa tämä kerros voisi generoida yksinkertaisen XML"-sivun, joka
muutettaisiin XHTML tai HTML "=sivuksi selaimen toimintoja varten.
Tällöin käyttöliittymäajurin voisi kirjoittaa esimerkiksi
XSLT"-kielellä. Käytännössä tällaisen ajurin kirjoittaminen muodostuu
oletettavasti niin hankalaksi, että paremmalta vaihtoehdolta tuntuu
kirjoittaa käyttöliittymäajuri kirjastoksi, joka
linkitetään\footnote{Joissakin ohjelmointiympäristöissä ohjelmakoodi
käännetään objektitiedostoiksi, jotka yhdistetään \emph{linkittämällä}
valmiin ohjelman tuottamiseksi. Vasta näin tuotettu valmis ohjelma
voidaan suorittaa. Toisaalta, esimerkiksi PHP"-kielisissä ohjelmissa
manuaalinen linkitys ei ole tarpeen, sillä se suoritetaan
automaattisesti ohjelman käynnistyessä kun kirjastoa on muutettu.}
ohjelmaan sitä tehtäessä. Linkitys pitää tehdä uudelleen kirjaston
päivityksen yhteydessä, mutta itse käyttöliittymän toiminnallisuuteen
ei tarvitse puuttua. Tässäkin mallissa eri sovellusten käyttöliittymät
saadaan säilymään yhdenmukaisina pelkästään linkittämällä kaikki
sovellukset uudelleen aina käyttöliittymäajurin päivityksen jälkeen.
\cite{w3:xml_v1_0,w3:xhtml,w3:xslt}

\subsection{Käyttöliittymäajuri}

Tämä kerros vastaa siitä kuinka käyttäjä pystyy tekemään eri valinnat
ja toiminnot. Jos, käyttöliittymässä on kuvattu, että lomakkeella on 10
vaihtoehtoa, joista pitää valita täsmälleen yksi, niin tällöin
selainkäyttöisen sovelluksen käyttöliittymäajuri voi näyttää sivulla 10
linkkiä, joista käyttäjä painaa yhtä. \emph{Vaihtoehtoisesti} ajuri
voisi näyttää lomakkeen jossa on 10 \alt{radio button} "=tyyppistä
elementtiä ja OK"-painike. Kolmas vaihtoehto olisi näyttää
\alt{combobox}"-alasvetovalikko yhdistettynä JavaScript"-käsittelijään,
joka lähettäisi lomakkeen välittömästi käyttäjän näpäytettyä jotain
kohtaa. Optimaalisessa tapauksessa käyttöliittymäajuri osaisi käyttää
kaikkia näitä vaihtoehtoja ja käyttäjä voisi omissa asetuksissaan
valita millä tyylillä hän haluaa käyttää erityyppisiä lomakkeita.

\subsection{Käyttöliittymäajurin tehtäväksi jää huolehtia kaikista
selainkäyttöisten ohjelmien ongelmista}

Koska selainkäyttöisen sovelluksen käyttäjä voi esimerkiksi haarauttaa
istunnon ja tästä toiminnosta ei synny tapahtumaa palvelimelle, täytyy
kaikki tieto kuljettaa lomakkeen muun tiedon yhteydessä sivuun
upotettuna. Tällöin tieto kahdentuu automaattisesti, kun käyttäjä
kahdentaa istunnon eli käytännössä avaa uuden ikkunan, jossa on sama
sovellus toiminnassa. Samoin historiatoimintojen yhteydessä selain
käyttää automaattisesti entisen lomakkeen tietoja, sillä nuo tiedot
sisältyvät siihen sivuun, jota selain käyttää sivun näyttämiseenkin.
Käyttöliittymäajuri ei voi estää vanhentuneen tiedon saapumista, joten
käyttöliittymän toiminnallisuuden tai sovelluslogiikan täytyy ottaa
siihen kantaa.\footnote{Käyttäjä voisi esimerkiksi muokata
selainkäyttöliittymällä uutisartikkelia, poistaa artikkelin ja käyttää
\emph{takaisin} toimintoa palatakseen takaisin muokkaus-toimintoon. Kun
käyttäjä nyt tallentaa tehdyt muokkaukset täytyy sovelluksen joko
palauttaa poistettu artikkeli tai luoda lähetettyjen tietojen
perusteella uusi tai käyttäjän lähettämää tieto hukkuu.}

Istunnon ylläpitoon tarvittavan tiedon määrän täytyy olla pieni, koska
kaikkien sovelluksen generoimien sivujen sisältämien linkkien täytyy
sisältää myös istunnon tiedot.\footnote{WWW"-sivulla olevat linkit
käyttävät aina GET"-metodia HTTP"-yhteyksiä käytettäessä, jossa kaikki
linkin parametrit pitää siirtää tekstinä osoitteen lopussa. Istuntoon
liittyvät tiedot täytyy siis toistaa sivun \emph{jokaisen} linkin
lopussa ja sivu kasvaa huomattavan nopeasti linkkien lukumäärän mukaan
jos istunto"-tietoa on paljon.} HTTP"-protokolla määrittelee
tavallisten linkkien käyttämän GET"-toiminnon maksimidatamääräksi neljä
kilotavua, joka asettaa ylärajan istunnon koolle.
\cite{ietf:http}

Koska \emph{kaikkien} sovellusten tietojen lähettäminen jokaisen
lomakkeen yhteydessä vaatisi huomattavan lisän tarvittavaan
tiedonsiirtokaistaan, tulee ohjelman toteutuksessa erikseen jakaa
istunto"-tiedot kahteen osaan: lomakkeiden kautta siirtyvä tieto, ja
tieto, joka voidaan jakaa myös haarautettujen tai vanhentuneiden
tapahtumien kanssa. Tällöin jaettu tieto voidaan säilyttää
palvelimella. Tällaista jaettua tietoa olisivat esimerkiksi käyttäjän
henkilökohtaiset asetukset, jotka voidaan jakaa eri ikkunoiden kesken.
Esimerkiksi valittu koko sivuston tyyli tai päivämäärien esitysmuoto
olisi tällaista tietoa. Jakamatonta istuntotietoa olisi taas
esimerkiksi tieto siitä, mitä toimintoja käyttäjä käytti saapuessaan
nykyiseen näkymään, jos tätä tietoa tarvitaan tulevaisuudessa.

Tulevaisuudessa selainkäyttöisen sovelluksen käyttöliittymäajuri voisi
esittää käyttöliittymän XForms"-määrityksen mukaisilla lomakkeilla,
jolloin käyttöliittymän toiminnallisuus ja ulkonäkö voidaan pitää
erillään www"-selaimeen asti. Ikävä kyllä XForms on hyvin heikosti
tuettu uusimmissakin selaimissa ja mikään ei viittaa siihen, että
tilanteeseen olisi tulossa nopeasti muutosta.
\cite{korpela:html_forms,w3:xforms}

\subsection{Huomioita käyttöliittymäajurin toteuttamiseen liittyen}

Koska eri selaimissa on erilaisia vikoja, ei käyttöliittymäajuri voi
ainoastaan tuottaa standardinmukaisia lomakkeita, vaan sen täytyy
yrittää tunnistaa asiakasohjelma (selaintyyppi ja versio) ja kiertää
jollakin tavalla siinä tunnetut ongelmat. Viallisten selainten tukeen
kuluva työaika on helpompi perustella, koska ajuri on yhteinen monelle
eri sovellukselle, joten kustannukset ohjelmaa kohden ovat pienempiä
kuin perinteisellä mallilla. Eräissä, erityisesti ulkonäköön liittyvisä
yksityiskohdissa, samaan lopputulokseen on mahdollista pyrkiä usealla
eri tavalla standardin puitteissa ja näistä täytyy kokeilemalla etsiä
se malli, joka toimii eri selaimissa. Tällöin eri selaimia varten ei
tarvitse kirjoittaa selainkohtaisia ominaisuuksia.

Koska käyttöliittymäajurin täytyy huolehtia kaikista selaimen käytöstä
johtuvista ongelmista, on sen toteuttaminen vaikeaa. HTML"-kieltä
tukevan ajurin ei kuitenkaan tarvitse ottaa kantaa käyttöliittymän
yksityiskohtiin, ainoastaan eri komponenttien järjestykseen, sillä
ulkonäölliset yksityiskohdat, kuten värit ja elementtien asemoinnit
voidaan käsitellä vasta selaimessa käyttäjän tietokoneella CSS"-kielen
avulla \cite{w3:css}. Sovellukselle voidaan helposti tuottaa erilaisia
ulkoasuja (\alt{skins}) pelkästään luomalla erilaisia CSS"-tiedostoja.
Lisäksi standardi mahdollistaa eri CSS"-tiedostojen kirjoittamisen
esimerkiksi normaalille selaimelle, dataprojektorille ja
kämmentietokoneille; käyttöliittymän ulkoasu on siis mahdollista hioa
tarvittaessa laitekohtaisesti.

\section{Nelikerroksisen mallin käytännön ongelmia}

Aloin toteuttamaan käyttöliittymäajuriajatusta Peda.net"-hankkeessa
tehtävän Oppimappi"-nimisen työkalun
valmistuksessa\footnote{Oppimappi"-työkalusta kerrotaan tarkemmin
luvussa \ref{pedanet-oppimappi}}. Peda.net"-hankkeessa on päätetty
yhdenmukaistaa sovellusten toimintaympäristöksi Apache"-www"-palvelimen
päällä toimiva PHP"-ohjelmointiympäristö sekä MySQL"-tietokanta, joten
tämä asetti käytännön rajoituksia ohjelman loogiseen rakenteeseen;
nykyisin käytössä oleva PHP"-kielen versio 4 ei tue moniperintää eikä
rajapintaluokkia, joten luokkahierarkian toteuttaminen vaati osin
teoriittisesta mallista poikkeamista.

% Oppimappia voi käyttää sekä MySQL
% että PostgreSQL "=tietokantojen päällä. Nykyisellä palvelimella MySQL
% toimii nopeammin.

Kuvassa \ref{fig:vihko-schema-orig} on esitetty osa alkuperäisestä
luokkahierarkiasta.

%Kuvassa \ref{fig:vihko-big-picture} on puolestaan
%mallinnettu ympäristöä isommassa mittakaavassa. Käytännössä
%MySQL"-tietokanta ja Oppimappi PHP"-sovellus toimivat
%Peda.net"-hankkeen ylläpitämällä palvelimella ja ohjelman
%käyttöliittymä esitetään HTML ja CSS "=kielien avulla sovelluksen
%käyttäjän koneessa toimivassa www"-selaimessa.

\begin{kuva}
\includegraphics[width=\linewidth]{kuvat/vihko-schema-orig}
\caption{Alkuperäistä suunnitelmaa Oppimapin toteuttamiseksi}
\label{fig:vihko-schema-orig}
\end{kuva}

Noin kuukauden kehitystyön jälkeen kävi kuitenkin selväksi, että
PHP"-ympäristön suorituskyky olioiden luomisessa ja tuhoamisessa oli
aika heikko. Lisäksi täydellisen käyttöliittymäajurin tekeminen alkoi
varmistumaan liian työlääksi siitä saataviin etuihin verrattuna.

\section{Sovelluskehys avuksi}

Päädyin siihen johtopäätökseen, että täydellistä käyttöliittymäajuria
ei kannata tehdä, koska varsinaisen sovelluslogiikan ja käyttäjän
välissä on niin useita tasoja, jakamalla käyttöliittymä sopivasti HTML
ja CSS -kielien vastuulle, käyttöliittymäajuri voidaan pitää hyvin
yksinkertaisena. Tätä on havainnollistettu kuvassa
\ref{fig:vihko-big-picture} Lisäksi, koska PHP rajaa ainakin
toistaiseksi natiivin käyttöliittymän kehittämisen mahdollisuuksia
suoritusympäristönsä vuoksi, ei natiivisovelluksen kehittämisen
helpottamiseksi kannattanut tässä vaiheessa uhrata aikaa.

\begin{kuva}
\includegraphics[width=4.5cm]{kuvat/vihko-big-picture}
\caption{Oppimapin rakenne kerroksina}
\label{fig:vihko-big-picture}
\end{kuva}


Päädyin loppujen lopuksi kuvassa \ref{fig:vihko-schema-current}
esitettyyn ratkaisuun. Tässäkin luokkahierarkia on ensisilmäyksellä
vähintäänkin outo, mutta ratkaisun taustalla kummittelee vaillinainen
oliotuki PHP-kielessä. Tätä kirjoittaessa PHP5 on jo ilmestynyt ja
siinä joitakin ongelmia onkin korjattu, mutta sen tuotantokäyttöä
kannattanee harkita aikaisintaan ensi vuonna.

\begin{kuva}
\includegraphics[width=\linewidth]{kuvat/vihko-schema-current}
\caption{Osa toteutetusta Oppimapin rakenteesta}
\label{fig:vihko-schema-current}
\end{kuva}

Oppimapin kehittämisessä havaittujen ongelmien ratkaisemiseksi
sovelluskehyksen kehittäminen vaikutti parhaalta ratkaisulta, koska
tällöin varsinaisen sovelluslogiikan koodi saadaan yksinkertaiseksi.
Sovelluslogiikkaan tuli mahdollisimman vähän sovelluksen toimintaan
liittymätöntä ohjelmakoodia, joten uusien, samaa sovelluskehystä
käyttävien sovellusten teko nopeutuisi. Myös lokalisointiin tarvittava
logiikka on yhteinen eri sovellusten välillä. Tätä kirjoittaessa
vaikuttaa siltä, että suurin osa Peda.netin tulevista sovelluksista
voidaan kirjoittaa Oppimapin moduuleiksi. Oppimapin rakenteesta voidaan
tarvittaessa rakentaa myös muita toimintaympäristöjä jättämällä osa
käytössä olevista moduuleista pois tai korvaamalla niitä uusilla.

Kaikki Oppimapin moduulit peritään luokasta \class{Document} (ks. kuva
\ref{fig:vihko-schema-current}) ja kaikki moduulit saavat oman
nimiavaruuden käyttämilleen parametreille. Tämä on olennaista, koska
istuntoon liittyvää tietoa täytyy kuljettaa kaikkien linkkien
osoitteissa. Eri moduulien parametrit sijoitetaan omiin
nimiavaruuksiinsa sen vuoksi, että useita moduuleita olisi mahdollista
esittää rinnakkain samalla sivulla. Automaattinen uudelleennimeäminen
mahdollistaa myös sen, että yksittäistä moduulia ohjelmoitaessa ei
tarvitse tarkistaa mitä nimiä muut moduulit käyttävät. Esimerkiksi jos
moduuli, jonka id"-numero on \code{251} asettaa sivulle parametrin,
jonka nimi on \code{foo}, käytetään todellisena parametrin nimenä
merkkijonoa \code{p251xfoo}. Nimen muunnos tapahtuu automaattisesti
\class{DocumentUI}"-luokan toimesta.  Lisäksi
\class{DocumentUI}"-luokka ylläpitää automaattisesti istuntotietoa,
johon kuuluu globaali \code{session}"-parametri, joka sisältää
käyttäjän ja tietokannan tunnistetiedot sekä varmenteen tietojen
muuttumattomuudesta. Kaikkiin toimintoihin lisätään myös kullakin
hetkellä käytössä olevan moduulin tunniste sekä edellisen käytössä
olleen moduulin tunniste. Näiden tietojen avulla moduulin kaikista
toiminnoista palataan oletuksena takaisin samaan moduuliin, mutta
esimerkiksi \emph{tallenna}"-toiminnon jälkeen voidaan palata
edelliseen moduuliin. Tämän voi ajatella vastaavan tavallisessa
käyttöjärjestelmässä ikkunan sulkemista, jonka jälkeen aktiiviseksi
vaihtuisi edellinen ikkuna.

Koska kaikki nämä tiedot viedään jokaiseen sivuun upotettuna, toimii
edellliseen näkymään palaaminen myös historian kautta avatuissa
sivuissa oikein. Myöskään ikkunan kahdentaminen ei aiheuta ongelmia.
